/*
 * CodeGenerator.cpp
 *
 *  Created on: May 22, 2019
 *      Author: derommo
 */

#include "CodeGenerator.h"

#include <iostream>
#include <string.h>
#include <stdint.h>

#include "GlobalDefines.h"
#include "Ring.h"
#include "Interface.h"

#define fprintProtect(ret) \
	{if(0 > ret) \
	{ \
		Error("fprintf on File %s failed: %s\n", path_.c_str(), strerror(errno)); \
		return false; \
	} \
	}

#define SNPRINTF(pt, size, ...) \
	{ \
		int ret = snprintf(pt, size, __VA_ARGS__); \
		if(0 > ret) \
		{ \
			Error("snprintf failed: %s!\n", strerror(errno)); \
			return false; \
		} \
		else if((int) size <= ret) \
		{ \
			Error("snprintf failed: Buffer too small: Size %lu, need %u\n", size, ret + 1); \
			return false; \
		} \
	}

#define retFalseOnFalse(boolean, ...) \
		{ \
			if(!boolean) \
			{ \
				Error(__VA_ARGS__); \
				return false; \
			} \
		}

#define HEADER_NAME "dac.h"

static const char fileName[] = "dac";


static const char includeFilesBrackets[][42] = {
		"stddef.h"
};

static const char includeFilesQuotes[][42] = {
		HEADER_NAME,
};

static const char headerLines[][100] = {
		"/*",
		" * Distributed Algebraic Computations",
		" * Copyright (C) 2019  Patrik Omland",
		" * This program is free software: you can redistribute it and/or modify",
		" * it under the terms of the GNU General Public License as published by",
		" * the Free Software Foundation, either version 3 of the License, or",
		" * (at your option) any later version.",
		" *",
		" * This program is distributed in the hope that it will be useful,",
		" * but WITHOUT ANY WARRANTY; without even the implied warranty of",
		" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
		" * GNU General Public License for more details.",
		" *",
		" * You should have received a copy of the GNU General Public License",
		" * along with this program. If not, see <http://www.gnu.org/licenses/>.",
		" *",
		" * This program was generated by DAC \"Distributed Algebraic Computations\"",
		" * The source code for the generator is available on GitHub",
		" * https://github.com/siquus/dac",
		" */",
		"",
};

CodeGenerator::CodeGenerator(const std::string* path) {
	path_ = *path;
}

CodeGenerator::~CodeGenerator() {
	if(nullptr != outfile_)
	{
		fclose(outfile_);
	}

	if(nullptr != outHeaderFile_)
	{
		fclose(outHeaderFile_);
	}
}

bool CodeGenerator::Generate(const Graph* graph)
{
	graph_ = graph;

	retFalseOnFalse(FetchVariables(), "Could not fetch variables\n");

	std::string pathAndFileName = path_ + fileName;

	outfile_ = fopen((pathAndFileName + ".c").c_str(), "w");
	if(nullptr == outfile_)
	{
		Error("Open File %s failed: %s\n", (pathAndFileName + ".c").c_str(), strerror(errno));
		return false;
	}

	outHeaderFile_ = fopen((pathAndFileName + ".h").c_str(), "w");
	if(nullptr == outfile_)
	{
		Error("Open File %s failed: %s\n", (pathAndFileName + ".h").c_str(), strerror(errno));
		return false;
	}

	for(uint16_t line = 0; line < sizeof(headerLines) / sizeof(headerLines[0]); line++)
	{
		fprintProtect(fprintf(outfile_, "%s\n", headerLines[line]));
		fprintProtect(fprintf(outHeaderFile_, "%s\n", headerLines[line]));
	}

	retFalseOnFalse(GenerateIncludes(), "Could not generate Includes\n");

	auto constHeading = std::string("Constant Variables");
	retFalseOnFalse(GenerateHeading(&constHeading), "Constant Heading failed!\n");

	retFalseOnFalse(GenerateConstantDeclarations(), "Could not generate Constants\n");

	auto staticHeading = std::string("Static Variables");
	retFalseOnFalse(GenerateHeading(&staticHeading), "Static Heading failed!\n");

	retFalseOnFalse(GenerateStaticDeclarations(), "Could not generate Statics\n!");

	retFalseOnFalse(GenerateOutputFunctions(), "Could not generate Output Functions\n!");

	return true;
}

bool CodeGenerator::GenerateConstantDeclarations()
{
	for(const std::pair<Graph::NodeId_t, Variable> &varPair: variables_)
	{
		const Variable * var = &varPair.second;
		if(var->HasProperty(Variable::PROPERTY_GLOBAL) && var->HasProperty(Variable::PROPERTY_CONST))
		{
			std::string decl;
			retFalseOnFalse(var->GetDeclaration(&decl), "Could not get declaration!\n");

			fprintProtect(fprintf(outfile_, "%s\n", decl.c_str()));
		}
	}

	return true;
}

bool CodeGenerator::GenerateStaticDeclarations()
{
	for(const std::pair<Graph::NodeId_t, Variable> &varPair: variables_)
	{
		const Variable * var = &varPair.second;
		if(var->HasProperty(Variable::PROPERTY_CONST))
		{
			// Constants are handled in another function
			continue;
		}

		if(var->HasProperty(Variable::PROPERTY_GLOBAL) && var->HasProperty(Variable::PROPERTY_STATIC))
		{
			std::string decl;
			retFalseOnFalse(var->GetDeclaration(&decl), "Could not get declaration!\n");

			fprintProtect(fprintf(outfile_, "%s\n", decl.c_str()));
		}
	}

	return true;
}

bool CodeGenerator::FetchVariables()
{
	// Fetch all variables
	auto nodes = graph_->GetNodes();
	for(const Graph::Node_t &node: *nodes)
	{
		std::string identifier;
		Variable::properties_t properties = Variable::PROPERTY_NONE;
		Variable::Type type = Variable::Type::none;
		size_t length = 1;
		const void * value;

		char tmpIdStr[42];
		SNPRINTF(tmpIdStr, sizeof(tmpIdStr), "Node%u", node.id);
		identifier.append(tmpIdStr);

		switch(node.objectType)
		{
		case Graph::ObjectType::MODULE_VECTORSPACE_VECTOR:
		{
			auto vector = (const Algebra::Module::VectorSpace::Vector*) node.object;
			value = vector->__value_;
			length = vector->__space_->dim_;
			switch(vector->__space_->ring_)
			{
			case Algebra::Ring::Type::Float32:
				type = Variable::Type::float_;
				break;

			case Algebra::Ring::Type::None: // no break intended
			default:
				Error("Unknown Ring!\n");
				return false;
			}

			if(nullptr != vector->__value_)
			{
				properties = (Variable::properties_t) (
						properties |
						Variable::PROPERTY_GLOBAL |
						Variable::PROPERTY_STATIC |
						Variable::PROPERTY_CONST);
			}
		}
		break;

		case Graph::ObjectType::INTERFACE_OUTPUT:
			// No variables to create
			break;

		default:
			Error("Unknown ObjectType!\n");
			return false;
		}

		if(variables_.end() != variables_.find(node.id))
		{
			Error("Variable already exists!\n");
			return false;
		}

		variables_.insert(
				std::make_pair(
						node.id,
						Variable(&identifier, properties, type, length, value)));
	}

	// Identify Outputs and mark output variables as such
	for(const Graph::Node_t &node: *nodes)
	{
		if(Graph::NodeType::OUTPUT != node.nodeType)
		{
			continue;
		}

		// Find all variables of the output's parents, i.e. the nodes that
		// shall be output
		for(const Graph::Node_t &potparnode: *nodes)
		{
			for(const Graph::NodeId_t &parentNodeId: node.parents)
			{
				if(parentNodeId != potparnode.id)
				{
					continue;
				}

				// Found output parent variable
				auto var = variables_.find(parentNodeId);
				if(variables_.end() == var)
				{
					Error("Parent Variable does not exists!\n");
					return false;
				}

				var->second.AddProperty(Variable::PROPERTY_GLOBAL);
				var->second.AddProperty(Variable::PROPERTY_STATIC);
			}
		}
	}

	// TODO: Identify constant variables!

	return true;
}

bool CodeGenerator::GenerateOutputFunctions()
{
	std::string fctDefinitions;

	auto nodes = graph_->GetNodes();
	for(const Graph::Node_t &node: *nodes)
	{
		if(Graph::NodeType::OUTPUT != node.nodeType)
		{
			continue;
		}

		auto * output = (const Interface::Output* ) node.object;

		for(const Graph::NodeId_t &nodeId: node.parents)
		{
			// Get Variable attached to node
			const auto var = variables_.find(nodeId);
			if(variables_.end() == var)
			{
				Error("Variable does not exist!\n");
				return false;
			}

			std::string fctPtTypeId = "DacOutputCallback";
			fctPtTypeId += *(output->GetOutputName(nodeId));

			std::string callbackTypedef;
			callbackTypedef += "typedef void (*";
			callbackTypedef += fctPtTypeId;
			callbackTypedef += "_t)(";
			callbackTypedef += var->second.GetTypeString();
			callbackTypedef += "* pt, size_t size);";

			// Export function prototype
			fprintProtect(fprintf(outHeaderFile_, "%s\n", callbackTypedef.c_str()));
			fprintProtect(fprintf(outHeaderFile_, "extern void %s_Register(%s_t callback);\n",
					fctPtTypeId.c_str(),
					fctPtTypeId.c_str()));

			// Declare Static Variables keeping the callback pointers
			fprintProtect(fprintf(outfile_, "static %s_t %s = NULL;",
					fctPtTypeId.c_str(),
					fctPtTypeId.c_str()));

			// Define Function
			char tmpBuff[100];
			SNPRINTF(tmpBuff, sizeof(tmpBuff), "void %s_Register(%s_t callback)\n{\n",
					fctPtTypeId.c_str(),
					fctPtTypeId.c_str());

			fctDefinitions += tmpBuff;

			SNPRINTF(tmpBuff, sizeof(tmpBuff), "\t %s = callback;\n", fctPtTypeId.c_str());
			fctDefinitions += tmpBuff;
			fctDefinitions += "}\n\n";
		}
	}

	fprintProtect(fprintf(outfile_, "\n"));

	auto exportedHeading = std::string("Exported Functions");
	retFalseOnFalse(GenerateHeading(&exportedHeading), "Exported Heading failed!\n");

	fprintProtect(fprintf(outfile_, "%s\n", fctDefinitions.c_str()));

	return true;
}

bool CodeGenerator::GenerateHeading(const std::string * heading)
{
	const uint16_t headingWidth = 100;

	std::string starSpangledHeading;
	starSpangledHeading.reserve(headingWidth);

	starSpangledHeading += "\n/* ";
	starSpangledHeading += *heading;
	starSpangledHeading += " ";

	while(headingWidth > starSpangledHeading.length())
	{
		starSpangledHeading += "*";
	}

	fprintProtect(fprintf(outfile_, "%s*/\n", starSpangledHeading.c_str()));

	return true;
}

bool CodeGenerator::GenerateIncludes()
{
	if(nullptr == outfile_)
	{
		Error("Output file is not open!\n");
		return false;
	}

	for(uint16_t incl = 0; incl < sizeof(includeFilesBrackets) / sizeof(includeFilesBrackets[0]); incl++)
	{
		fprintProtect(fprintf(outfile_, "#include <%s>\n", includeFilesBrackets[incl]));
	}

	for(uint16_t incl = 0; incl < sizeof(includeFilesQuotes) / sizeof(includeFilesQuotes[0]); incl++)
	{
		fprintProtect(fprintf(outfile_, "#include \"%s\"\n", includeFilesQuotes[incl]));
	}

	return true;
}

inline bool Variable::HasProperty(properties_t property) const
{
	if(properties_ & property)
	{
		return true;
	}

	return false;
}

const char* Variable::GetTypeString() const
{
	static const char typeStrings[(int) Type::nrOf][30] = {
			"0000", // make sure it throws error
			"uint8_t",
			"int8_t",
			"float",
	};

	switch(type_)
	{
	case Type::uint8_:
		return typeStrings[(int) Type::uint8_];

	case Type::int8_:
		return typeStrings[(int) Type::int8_];

	case Type::float_:
		return typeStrings[(int) Type::float_];

	default: // no break intended
	case Type::none:
		Error("Unknown Type!\n");
		return nullptr;
	}

	return nullptr; // should not be reached
}

bool Variable::AddProperty(properties_t property)
{
	switch(property)
	{
	case PROPERTY_CONST: // no break intended
	case PROPERTY_STATIC: // no break intended
	case PROPERTY_GLOBAL:
		break;

	default:
		Error("Unknown property!\n");
		return false;
	}

	properties_ = (properties_t) (properties_ | property);

	return true;
}

Variable::Variable(const std::string* identifier, properties_t properties, Type type, size_t length, const void* value)
{
	value_ = value;

	if(PROPERTY_END_OF_ENUM <= properties)
	{
		Error("Unknown properties specified!\n");
		return;
	}
	properties_ = properties;

	type_ = type;
	length_ = length;

	if(nullptr == identifier)
	{
		Error("Nullpointer!\n");
		return;
	}

	identifier_ = *identifier;
}

bool Variable::GetDeclaration(std::string* decl) const
{
	if(properties_ & PROPERTY_STATIC)
	{
		decl->append("static ");
	}

	if(properties_ & PROPERTY_CONST)
	{
		decl->append("const ");
	}

	const char* typeStr = GetTypeString();
	if(nullptr == typeStr)
	{
		Error("Unknown type!\n");
		return false;
	}

	decl->append(typeStr);
	decl->append(" ");

	if(0 == identifier_.length())
	{
		Error("Identifier not set!\n");
		return false;
	}

	decl->append(identifier_);

	if(1 < length_) // this is an array
	{
		char tmpBuff[40];
		SNPRINTF(tmpBuff, sizeof(tmpBuff), "[%lu]", length_);
		decl->append(tmpBuff);
	}

	// Any initializer supplied?
	if(properties_ & PROPERTY_CONST)
	{
		if(nullptr == value_)
		{
			Error("Const variable requires initializer!");
			return false;
		}
	}

	if(nullptr == value_)
	{
		decl->append(";");
		return true;
	}

	decl->append(" = ");

	if(1 < length_)
	{
		decl->append("{");
	}

	for(uint32_t elem = 0; elem < length_; elem++)
	{
		char tmpBuff[42];
		switch(type_)
		{
		case Type::uint8_: // no break intended
		case Type::int8_:
			Error("Type not implemented!\n");
			return false;

		case Type::float_:
		{
			float* valuePt = (float*) value_;
			SNPRINTF(tmpBuff, sizeof(tmpBuff), "%f", valuePt[elem]);
		}
		break;

		default:
			Error("Unknown Type\n");
			return false;
		}

		decl->append(tmpBuff);

		if(elem != length_ -1)
		{
			decl->append(", ");
		}
	}

	if(1 < length_)
	{
		decl->append("}");
	}

	decl->append(";");

	return true;
}

const std::string* Variable::GetIdentifier() const
{
	if(0 == identifier_.length())
	{
		Error("Identifier not set!\n");
		return nullptr;
	}

	return &identifier_;
}

bool Variable::GetElement(std::string* elem, uint32_t elemIndex) const
{
	if(1 >= length_)
	{
		Error("Variable %s not an Array!\n", identifier_.c_str());
		return false;
	}

	if(length_ <= elemIndex)
	{
		Error("Element index %u out of array length %lu!\n", elemIndex, length_);
		return false;
	}

	if(0 == identifier_.length())
	{
		Error("Identifier not set!\n");
		return false;
	}

	elem->append(identifier_);

	char tmpBuff[40];
	SNPRINTF(tmpBuff, sizeof(tmpBuff), "[%u]", elemIndex);
	elem->append(tmpBuff);

	return true;
}

size_t Variable::Length() const
{
	return length_;
}


