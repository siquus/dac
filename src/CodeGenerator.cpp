/*
 * CodeGenerator.cpp
 *
 *  Created on: May 22, 2019
 *      Author: derommo
 */

#include "CodeGenerator.h"

#include <iostream>
#include <string.h>
#include <stdint.h>
#include <cstdarg>
#include <algorithm>
#include <float.h>

#include "GlobalDefines.h"
#include "Ring.h"
#include "Interface.h"
#include "Module.h"
#include "embeddedFiles.h"

#include "ControlTransfer.h"

#define SNPRINTF(pt, size, ...) \
	{ \
		int ret = snprintf(pt, size, __VA_ARGS__); \
		if(0 > ret) \
		{ \
			Error("snprintf failed: %s!\n", strerror(errno)); \
			return false; \
		} \
		else if((int) size <= ret) \
		{ \
			Error("snprintf failed: Buffer too small: Size %lu, need %u\n", size, ret + 1); \
			return false; \
		} \
	}

#define retFalseOnFalse(boolean, ...) \
		{ \
			if(!boolean) \
			{ \
				Error(__VA_ARGS__); \
				return false; \
			} \
		}

#define getVarRetFalseOnError(pt, nodeId) \
	Variable* pt = GetVariable(nodeId); \
	if(nullptr == pt) \
	{ \
		Error("Variable for Node%u does not exist!\n", nodeId); \
		return false; \
	} \


static const char includeFilesBrackets[][42] = {
		"stdint.h",
		"stddef.h",
		"linux/types.h",
		"pthread.h"
};

// TODO: Add Version and commit hash
static const char fileHeader[] = \
"/*\n\
* Distributed Algebraic Computations\n\
* Copyright (C) 2019  Patrik Omland\n\
* This program is free software: you can redistribute it and/or modify\n\
* it under the terms of the GNU General Public License as published by\n\
* the Free Software Foundation, either version 3 of the License, or\n\
* (at your option) any later version.\n\
*\n\
* This program is distributed in the hope that it will be useful,\n\
* but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
* GNU General Public License for more details.\n\
*\n\
* You should have received a copy of the GNU General Public License\n\
* along with this program. If not, see <http://www.gnu.org/licenses/>.\n\
*\n\
* This program was generated by DAC \"Distributed Algebraic Computations\"\n\
* The source code for the generator is available on GitHub\n\
* https://github.com/siquus/dac\n\
*/\n\
\n";

static const uint32_t NODE_T_MAX_EDGE_NUMBER = 42;

FileWriter::~FileWriter()
{
	if(nullptr != outfile_)
	{
		if(fclose(outfile_))
		{
			Error("fclose failed: %s\n", strerror(errno));
		}
	}
}

bool FileWriter::Init(const std::string * path)
{
	path_ = *path;
	outfile_ = fopen(path_.c_str(), "w");
	if(nullptr == outfile_)
	{
		Error("Open File %s failed: %s\n", path_.c_str(), strerror(errno));
		return false;
	}

	// Print standard header
	int printRet = fprintf(outfile_, "%s\n", fileHeader);
	if(0 > printRet)
	{
		Fatal("fprintf to %s failed: %s\n", path_.c_str(), strerror(errno));
	}

	return true;
}

void FileWriter::Indent(uint8_t tabNumber)
{
	indentationLevel_ += tabNumber;
}

void FileWriter::Outdent(uint8_t tabNumber)
{
	if(indentationLevel_ < tabNumber)
	{
		Error("Indentation %u does not allow outdent of %u",
				indentationLevel_, tabNumber);

		return;
	}

	indentationLevel_ -= tabNumber;
}

void FileWriter::PrintfLine(const char * format, ...)
{
	va_list argList;
	va_start(argList, format);

	std::string formatStr;
	for(uint8_t tab = 0; tab < indentationLevel_; tab++)
	{
		formatStr += "\t";
	}

	formatStr += format;
	formatStr += "\n";

	int printRet = vfprintf(outfile_, formatStr.c_str(), argList);
	if(0 > printRet)
	{
		Fatal("vfprintf to %s failed: %s\n", path_.c_str(), strerror(errno));
	}
}

const std::string * FileWriter::Path() const
{
	return &path_;
}

CodeGenerator::CodeGenerator(const std::string* path) {
	path_ = *path;
}

CodeGenerator::~CodeGenerator() {

}

bool CodeGenerator::Generate(const Graph* graph)
{
	graph_ = graph;

	auto nodes = graph_->GetNodes();

	for(const auto &nodePair: *nodes)
	{
		DEBUG("nodeMap Node%2u: %s,\t\t ObjType %2u,  Children ",
				nodePair.first,
				Node::getName(nodePair.second.type),
				(unsigned int) nodePair.second.objectType);

		for(Node::Id_t nodeId: nodePair.second.children)
		{
			DEBUG("%u, ", nodeId);
		}
		DEBUG("Parents ");
		for(Node::Id_t nodeId: nodePair.second.parents)
		{
			DEBUG("%u, ", nodeId);
		}
		DEBUG("\n");
	}

	retFalseOnFalse(FetchVariables(), "Could not fetch variables\n");

	std::string pathAndFileName = path_ + "Dac" + graph->Name();
	std::string dacCPath = pathAndFileName + ".c";

	bool success = fileDacC_.Init(&dacCPath);
	if(!success)
	{
		Error("Could not initialize %s!", dacCPath.c_str());
		return false;
	}

	std::string dacHPath = pathAndFileName + ".h";
	success = fileDacH_.Init(&dacHPath);
	if(!success)
	{
		Error("Could not initialize %s!", dacHPath.c_str());
		return false;
	}

	std::string InstructionsPath = path_ + "Instructions" + graph->Name();
	std::string InstructionsC = InstructionsPath + ".c";
	success = fileInstructions_.Init(&InstructionsC);
	if(!success)
	{
		Error("Could not initialize %s!", InstructionsC.c_str());
		return false;
	}

	std::string InstructionsH = InstructionsPath + ".h";
	success = fileInstructionsH_.Init(&InstructionsH);
	if(!success)
	{
		Error("Could not initialize %s!", InstructionsH.c_str());
		return false;
	}

	// Copy files
	GenerateEmbeddedFiles(&path_);

	// Generate Includes
	retFalseOnFalse(GenerateIncludes(), "Could not generate Includes\n");
	fileDacC_.PrintfLine("");

	fileInstructions_.PrintfLine("#include <stdint.h>");
	fileInstructions_.PrintfLine("#include <math.h>\n");
	fileInstructions_.PrintfLine("#include \"Dac%s.h\"", graph_->Name().c_str());
	fileInstructions_.PrintfLine("#include \"Instructions%s.h\"\n", graph_->Name().c_str());

	// Generate Functions
	fileDacH_.PrintfLine("#ifdef __cplusplus");
	fileDacH_.PrintfLine("extern \"C\" {");
	fileDacH_.PrintfLine("#endif // __cplusplus\n");
	fileDacH_.PrintfLine("#include <stddef.h>\n");
	retFalseOnFalse(GenerateOutputFunctions(), "Could not generate Output Functions\n!");
	fileInstructions_.PrintfLine("");

	// Generate Variables
	retFalseOnFalse(GenerateConstantDeclarations(), "Could not generate Constants\n");
	fileInstructions_.PrintfLine("");
	retFalseOnFalse(GenerateStaticVariableDeclarations(), "Could not generate Statics\n!");
	fileInstructions_.PrintfLine("");

	auto runHeading = std::string("The main run routine");
	retFalseOnFalse(GenerateHeading(&runHeading), "Run Heading failed!\n");

	retFalseOnFalse(GenerateRunFunction(), "Could not generate Run Function!\n");

	fileInstructions_.PrintfLine("static node_t nodes%s[]; // Initialized below\n", graph_->Name().c_str()); // TODO: This seems dirty.

	retFalseOnFalse(GenerateInstructions(), "Could not generate Instructions!\n");

	retFalseOnFalse(GenerateNodesArray(), "Could not generate Nodes Array");

	fileDacH_.PrintfLine("#ifdef __cplusplus");
	fileDacH_.PrintfLine("}");
	fileDacH_.PrintfLine("#endif // __cplusplus\n");

	return true;
}

bool CodeGenerator::GenerateNodesArray()
{
	fileInstructions_.PrintfLine("static node_t nodes%s[] = {", graph_->Name().c_str());
	fileInstructions_.Indent();

	// Write array
	for(const auto &nodePair: nodesInstructionMap_)
	{
		// Only include parents/children which require an instruction
		std::vector<uint32_t> parentsArrayPosition;
		for(const Node::Id_t &parent: nodePair.second->parents)
		{
			if(nodesInstructionMap_.end() != nodesInstructionMap_.find(parent))
			{
				const auto &arrayPos = nodeArrayPos_.find(parent);
				if(nodeArrayPos_.end() == arrayPos)
				{
					Error("Couldn't find array position");
					return false;
				}

				parentsArrayPosition.push_back(arrayPos->second);
			}
		}

		std::vector<uint32_t> childrenArrayPosition;
		if(nodePair.second->type != Node::Type::CONTROL_TRANSFER_WHILE) // Control Transfers don't have children
		{
			for(const Node::Id_t &child: nodePair.second->children)
			{
				if(nodesInstructionMap_.end() != nodesInstructionMap_.find(child))
				{
					const auto &arrayPos = nodeArrayPos_.find(child);
					if(nodeArrayPos_.end() == arrayPos)
					{
						Error("Couldn't find array position");
						return false;
					}

					childrenArrayPosition.push_back(arrayPos->second);
				}
			}
		}

		retFalseOnFalse(
				GenerateNodesElem(
						nodePair.first,
						&parentsArrayPosition,
						&childrenArrayPosition),
				"Could not generate Nodes Element!");
	}

	fileInstructions_.Outdent();
	fileInstructions_.PrintfLine("};\n");

	// Create node-list to initialize job pool
	std::set<Node::Id_t> firstNodes;
	GetFirstNodesToExecute(&firstNodes);

	std::string jobPoolInitNodesId = "jobPoolInitNodes" + graph_->Name();
	std::string jobPoolInitNodes = "node_t * " + jobPoolInitNodesId + "[] = {";
	for(const auto &node: firstNodes)
	{
		const auto &arrayPos = nodeArrayPos_.find(node);
		if(nodeArrayPos_.end() == arrayPos)
		{
			Error("Couldn't find array position\n");
			return false;
		}

		jobPoolInitNodes += "&nodes" + graph_->Name() + "[";
		jobPoolInitNodes += std::to_string(arrayPos->second);
		jobPoolInitNodes += "]";
		jobPoolInitNodes += ", ";
	}

	jobPoolInitNodes.erase(jobPoolInitNodes.size() - 2); // Remove last ", "
	jobPoolInitNodes += "};\n";

	fileInstructions_.PrintfLine("%s", jobPoolInitNodes.c_str());

	std::string jobPoolInitId = "jobPoolInit_t jobPoolInit" + graph_->Name();
	fileInstructions_.PrintfLine("%s = {", jobPoolInitId.c_str());
	fileInstructions_.Indent();
	fileInstructions_.PrintfLine(".Nodes = %s,", jobPoolInitNodesId.c_str());
	fileInstructions_.PrintfLine(".NodesNrOf = %lu,", firstNodes.size());
	fileInstructions_.Outdent();
	fileInstructions_.PrintfLine("};");

	fileInstructionsH_.PrintfLine("#include \"Helpers.h\"\n");
	fileInstructionsH_.PrintfLine("\n");
	fileInstructionsH_.PrintfLine("extern %s;", jobPoolInitId.c_str());

	return true;
}

bool CodeGenerator::GetFirstNodesToExecute(std::set<Node::Id_t> * nodeSet)
{
	// Find all nodes which do not have parents and create a set of their children
	std::set<Node::Id_t> roots;

	auto nodes = graph_->GetNodes();
	for(const auto &nodePair: *nodes)
	{
		if(0 == nodePair.second.parents.size())
		{
			roots.insert(nodePair.second.id);
			std::copy(
					nodePair.second.children.begin(), nodePair.second.children.end(),
					std::inserter(*nodeSet, nodeSet->end()));
		}
	}

	// delete all children which have non-root parents.
	// i.e. these children may be executed right away.
	std::vector<Node::Id_t> nonFirstGenerationChildren;
	for(Node::Id_t childId: *nodeSet)
	{
		const auto childNodeIt =  nodes->find(childId);
		if(nodes->end() == childNodeIt)
		{
			Error("Unknown Child, NodeId = %u!\n", childId);
			return false;
		}

		const Node* childNode = &childNodeIt->second;

		for(Node::Id_t parentId: childNode->parents)
		{
			if(roots.end() == roots.find(parentId))
			{
				// Child has one non-first-generation parent.
				nonFirstGenerationChildren.push_back(childId); // erase later
				break;
			}
		}
	}

	for(Node::Id_t childId: nonFirstGenerationChildren)
	{
		nodeSet->erase(childId);
	}

	return true;
}

bool CodeGenerator::GenerateInstructions()
{
	Node::Id_t arrayPos = 0;
	const auto nodes = graph_->GetNodes();
	for(const auto &nodePair: *nodes)
	{
		// Does this node require a function?
		switch(nodePair.second.type)
		{
		default:
			Error("Unknown Node-Type %u\n", (uint8_t) nodePair.second.type);
			return false;

		case Node::Type::VECTOR: // no break intended
		case Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT:
			continue; // does not have instruction

		case Node::Type::CONTROL_TRANSFER_WHILE: // no break intended
		case Node::Type::VECTOR_ADDITION: // no break intended
		case Node::Type::VECTOR_SCALAR_PRODUCT: // no break intended
		case Node::Type::VECTOR_VECTOR_PRODUCT: // no break intended
		case Node::Type::VECTOR_POWER: // no break intended
		case Node::Type::VECTOR_CONTRACTION: // no break intended
		case Node::Type::VECTOR_COMPARISON_IS_SMALLER: // no break intended
		case Node::Type::VECTOR_PERMUTATION: // no break intended
		case Node::Type::VECTOR_PROJECTION: // no break intended
		case Node::Type::VECTOR_JOIN_INDICES: // no break intended
		case Node::Type::OUTPUT:
			break; // create instruction
		}

		// Create function identifier
		std::string fctId;
		GenerateInstructionId(&fctId, nodePair.second.id);

		// Set param to unused if not used
		if(Node::Type::CONTROL_TRANSFER_WHILE != nodePair.second.type)
		{
			fileInstructions_.PrintfLine("static void %s(void * instance __attribute__((unused)), void (*PushNode)(void * instance, struct node_s * node) __attribute__((unused)))", fctId.c_str());
		}
		else
		{
			fileInstructions_.PrintfLine("static void %s(void * instance, void (*PushNode)(void * instance, struct node_s * node))", fctId.c_str());
		}

		fileInstructions_.PrintfLine("{");
		fileInstructions_.Indent();

		retFalseOnFalse(GenerateOperationCode(
				&nodePair.second,
				&fileInstructions_),
				"Could not generate Operation Code!\n");

		// End function
		fileInstructions_.Outdent();
		fileInstructions_.PrintfLine("}\n");

		// Add node to "nodes with instruction"
		nodesInstructionMap_.insert(std::pair<Node::Id_t, const Node*>(nodePair.second.id, &nodePair.second));

		// Determine Nodes array positions
		nodeArrayPos_.insert(std::pair<Node::Id_t, uint32_t>(nodePair.second.id, arrayPos));
		arrayPos++;
	}

	return true;
}

bool CodeGenerator::GenerateCallbackPtCheck(FileWriter* file) const
{
	auto nodes = graph_->GetNodes();
	for(const auto &nodePair: *nodes)
	{
		if(Node::Type::OUTPUT != nodePair.second.type)
		{
			continue;
		}

		auto output = (const Interface::Output*) nodePair.second.object;

		file->PrintfLine("if(NULL == Dac%sOutputCallback%s)",
				graph_->Name().c_str(),
				output->GetOutputName()->c_str());
		file->PrintfLine("{");
		file->PrintfLine("\tfatal(\"Dac%sOutputCallback%s == NULL\");",
				graph_->Name().c_str(),
				output->GetOutputName()->c_str());
		file->PrintfLine("}\n");
	}

	return true;
}

bool CodeGenerator::GenerateInstructionId(std::string * InstrId, const Node::Id_t NodeId)
{
	if(nullptr == InstrId)
	{
		Error("nullptr");
		return false;
	}

	*InstrId = "Node";
	*InstrId += std::to_string(NodeId);
	*InstrId += "Instruction";

	return true;
}

bool CodeGenerator::GenerateNodesElem(
		const Node::Id_t nodeId,
		const std::vector<uint32_t> * parentsArrayPosition,
		const std::vector<uint32_t> * childrenArrayPosition)
{
	std::string instrId;
	GenerateInstructionId(&instrId, nodeId);

	std::string buffer;
	buffer += instrId;
	buffer += ", {";

	if(NODE_T_MAX_EDGE_NUMBER < parentsArrayPosition->size())
	{
		Error("Too many parent nodes!");
		return false;
	}

	for(uint32_t parent = 0; parent < parentsArrayPosition->size(); parent++)
	{
		buffer += "&";
		buffer += "nodes" + graph_->Name();
		buffer += "[";
		buffer += std::to_string((*parentsArrayPosition)[parent]);
		buffer += "]";

		if(parentsArrayPosition->size() - 1 > parent)
		{
			buffer += ", ";
		}
	}

	buffer += "}, {";

	if(NODE_T_MAX_EDGE_NUMBER < childrenArrayPosition->size())
	{
		Error("Too many child nodes!");
		return false;
	}

	for(uint32_t child = 0; child < childrenArrayPosition->size(); child++)
	{
		buffer += "&";
		buffer += "nodes" + graph_->Name();
		buffer += "[";
		buffer += std::to_string((*childrenArrayPosition)[child]);
		buffer += "]";

		if(childrenArrayPosition->size() - 1 > child)
		{
			buffer += ", ";
		}
	}

	buffer += "}, 0, ";
	buffer += std::to_string(parentsArrayPosition->size());
	buffer += ", ";
	buffer += std::to_string(childrenArrayPosition->size());
	buffer += ", ";
	buffer += std::to_string(nodeId);

	fileInstructions_.PrintfLine("{%s},", buffer.c_str());

	return true;
}

bool CodeGenerator::GenerateRunFunction()
{
	// Add prototype to header
	fileDacH_.PrintfLine("extern int Dac%sRun(size_t threadsNrOf);", graph_->Name().c_str());

	// Define function
	fileDacC_.PrintfLine("int Dac%sRun(size_t threadsNrOf)\n{", graph_->Name().c_str());
	fileDacC_.Indent();

	// Check that callbacks have been set
	GenerateCallbackPtCheck(&fileDacC_);

	// Fire up threads
	fileDacC_.PrintfLine("void * instance = NULL;");
	fileDacC_.PrintfLine("StartThreads(&instance, threadsNrOf, &jobPoolInit%s);", graph_->Name().c_str());

	// Join threads, create return values and closing brackets
	fileDacC_.PrintfLine("JoinThreads(instance);\n");

	// Return 0 to show success.
	fileDacC_.PrintfLine("return 0;\n}\n");

	return true;
}

bool CodeGenerator::OutputCode(const Node* node, FileWriter * file)
{
	file->PrintfLine("// %s\n", __func__);

	// Call corresponding function callbacks
	for(Node::Id_t outId: node->parents)
	{
		getVarRetFalseOnError(var, outId);

		auto output = (const Interface::Output*) node->object;

		const std::string * varIdentifier = var->GetIdentifier();
		if(nullptr == varIdentifier)
		{
			Error("Could not find Var. Identifier!\n");
			return false;
		}

		// If node is not an array, we need to take address
		std::string NodeStr;
		if(2 > var->Length())
		{
			NodeStr += "&";
		}
		NodeStr += *varIdentifier;

		file->PrintfLine("Dac%sOutputCallback%s(%s, sizeof(%s));\n",
				graph_->Name().c_str(),
				output->GetOutputName()->c_str(),
				NodeStr.c_str(),
				varIdentifier->c_str());
	}

	file->PrintfLine("");

	return true;
}

bool CodeGenerator::GenerateOperationCode(const Node* node, FileWriter * file)
{
	switch(node->type)
	{
	case Node::Type::VECTOR_ADDITION:
		retFalseOnFalse(VectorAdditionCode(node, file), "Could not generate Vector Addition Code!\n");
		break;

	case Node::Type::CONTROL_TRANSFER_WHILE:
		retFalseOnFalse(ControlTransferWhileCode(node, file),
				"Could not generatede Control Transfer While Code!\n");
		break;

	case Node::Type::VECTOR_SCALAR_PRODUCT:
		retFalseOnFalse(VectorScalarProductCode(node, file),
				"Could not generate Vector Scalar Product Code!\n");
		break;

	case Node::Type::VECTOR_POWER:
		retFalseOnFalse(VectorPowerCode(node, file),
				"Could not generate Vector Power Code!\n");
		break;

	case Node::Type::VECTOR_PROJECTION:
		retFalseOnFalse(VectorProjectionCode(node, file),
				"Could not generate Vector Projection Code!\n");
		break;

	case Node::Type::VECTOR_VECTOR_PRODUCT:
		retFalseOnFalse(VectorVectorProductCode(node, file),
				"Could not generate Vector Vector Product Code!\n");
		break;

	case Node::Type::VECTOR_JOIN_INDICES:
		retFalseOnFalse(VectorJoinIndicesCode(node, file),
						"Could not generate Vector Join Indices Code!\n");
		break;

	case Node::Type::VECTOR_COMPARISON_IS_SMALLER:
		retFalseOnFalse(VectorComparisonIsSmallerCode(node, file),
				"Could not generate Vector Comparison <= Code!\n");
		break;

	case Node::Type::OUTPUT:
		retFalseOnFalse(OutputCode(node, file),
				"Could not generate Output Code!\n");
		break;

	case Node::Type::VECTOR:
		Error("Type %i is no operation!\n", (int) node->type);
		return false;

	case Node::Type::VECTOR_CONTRACTION:
		retFalseOnFalse(VectorContractionCode(node, file),
		"Could not generate vector contraction Code!\n");
		break;

	case Node::Type::VECTOR_PERMUTATION:
		retFalseOnFalse(VectorPermutationCode(node, file),
				"Could not generate vector contraction Code!\n");
		break;

	default:
		Error("Unknown Type %i!\n", (int) node->type);
		return false;
	}

	return true;
}

bool CodeGenerator::GenerateLocalVariableDeclaration(const Variable * var)
{
	if(!var->HasProperty(Variable::PROPERTY_GLOBAL))
	{
		std::string varDecl;
		var->GetDeclaration(&varDecl);
		varDecl += "\n";
		fileDacC_.PrintfLine("\t%s", varDecl.c_str());
	}

	return true;
}

bool CodeGenerator::VectorAdditionCode(const Node* node, FileWriter * file)
{
	file->PrintfLine("// %s\n", __func__);

	getVarRetFalseOnError(varOp, node->id);
	getVarRetFalseOnError(varSum1, node->parents[0]);
	getVarRetFalseOnError(varSum2, node->parents[1]);

	GenerateLocalVariableDeclaration(varOp);

	auto vecOp = (const Algebra::Module::VectorSpace::Vector*) node->object;

	bool resultIsArray = (1 < vecOp->__space_->GetDim());

	if(resultIsArray)
	{
		file->PrintfLine("for(uint32_t dim = 0; dim < %u; dim++)",
				vecOp->__space_->GetDim());

		file->PrintfLine("{");

		file->PrintfLine("\t%s[dim] = %s[dim] + %s[dim];",
				varOp->GetIdentifier()->c_str(),
				varSum1->GetIdentifier()->c_str(),
				varSum2->GetIdentifier()->c_str());

		file->PrintfLine("}\n");
	}
	else
	{
		file->PrintfLine("%s = %s + %s;",
				varOp->GetIdentifier()->c_str(),
				varSum1->GetIdentifier()->c_str(),
				varSum2->GetIdentifier()->c_str());
	}

	return true;
}

bool CodeGenerator::VectorContractionKroneckerDeltaCode(const Node* node, FileWriter * file)
{
	file->PrintfLine("// %s\n", __func__);

	auto nodes = graph_->GetNodes();
	const auto lnode = nodes->find(node->parents[0]);
	if(nodes->end() == lnode)
	{
		Error("Could not find Node for id %u\n", node->parents[0]);
		return false;
	}

	const auto rnode = nodes->find(node->parents[1]);
	if(nodes->end() == rnode)
	{
		Error("Could not find Node for id %u\n", node->parents[1]);
		return false;
	}

	if((Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT == lnode->second.type) &&
			(Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT == rnode->second.type))
	{
		Error("Contraction of two KroneckerDeltas not supported: Should be handled in graph creation!\n");
		return false;
	}

	const Node * argVecNode;
	const Node * kronNode;
	bool argVecIsLeftArg;
	if(Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT == lnode->second.type)
	{
		argVecNode = &rnode->second;
		kronNode = &lnode->second;
		argVecIsLeftArg = false;
	}
	else
	{
		argVecNode = &lnode->second;
		kronNode = &rnode->second;
		argVecIsLeftArg = true;
	}

	getVarRetFalseOnError(varOp, node->id);
	getVarRetFalseOnError(varArgVec, argVecNode->id);

	const Algebra::Module::VectorSpace::Vector* argVec = (const Algebra::Module::VectorSpace::Vector*) argVecNode->object;
	const Algebra::Module::VectorSpace::Vector* kronVec = (const Algebra::Module::VectorSpace::Vector*) kronNode->object;
	const Algebra::Module::VectorSpace::Vector* opVec = (const Algebra::Module::VectorSpace::Vector*) node->object;

	const Node::contractParameters_t * contractValue = (const Node::contractParameters_t *) node->typeParameters;

	const std::vector<uint32_t> * argContractFactors;
	const std::vector<uint32_t> * kronContractFactors;
	if(argVecIsLeftArg)
	{
		argContractFactors = &contractValue->lfactors;
		kronContractFactors = &contractValue->rfactors;
	}
	else
	{
		argContractFactors = &contractValue->rfactors;
		kronContractFactors = &contractValue->lfactors;
	}

	const Algebra::Module::VectorSpace::KroneckerDeltaParameters_t * kroneckerParam = (const Algebra::Module::VectorSpace::KroneckerDeltaParameters_t *) kronNode->typeParameters;

	// Copy delta pairs array into file
	std::string deltaPairs = "const uint32_t deltaPairs[] = {";
	for(size_t paramPos = 0; paramPos < kroneckerParam->DeltaPair.size(); paramPos++)
	{
		deltaPairs += std::to_string(kroneckerParam->DeltaPair[paramPos]) + ", ";
	}
	deltaPairs.erase(deltaPairs.end() - 2, deltaPairs.end()); // remove last ", "
	deltaPairs += "};";
	file->PrintfLine("%s", deltaPairs.c_str());

	// Calculate Strides, assume Row-Major Layout
	// https://en.wikipedia.org/wiki/Row-_and_column-major_order#Address_calculation_in_general
	std::vector<uint32_t> argStrides;
	argVec->__space_->GetStrides(&argStrides);
	const char argStridesId[] = "argStrides";
	file->PrintfLine("const uint32_t %s[] = {", argStridesId);
	for(const uint32_t &stride: argStrides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};");

	const char * varOpId = varOp->GetIdentifier()->c_str();

	bool resultIsArray = (1 < varOp->Length());

	if(resultIsArray)
	{
		std::vector<uint32_t> opStrides;
		opVec->__space_->GetStrides(&opStrides);
		const char opstridesId[] = "opStrides";
		file->PrintfLine("const uint32_t %s[] = {", opstridesId);
		for(const uint32_t &stride: opStrides)
		{
			file->PrintfLine("\t %u,", stride);
		}
		file->PrintfLine("};\n");

		file->PrintfLine("for(size_t opIndex = 0; opIndex < sizeof(%s) / sizeof(%s[0]); opIndex++)",
				varOpId, varOpId);
		file->PrintfLine("{");
		file->Indent();

		std::string opIndexTuple = "const uint32_t opIndexTuple[] = {";
		for(uint32_t stride = 0; stride < opStrides.size(); stride++)
		{
			if(0 == stride)
			{
				opIndexTuple += "opIndex / ";
				opIndexTuple += opstridesId;
				opIndexTuple += "[";
				opIndexTuple += std::to_string(stride);
				opIndexTuple += "]";
				opIndexTuple += ", ";
			}
			else
			{
				opIndexTuple += "(opIndex % opStrides[";
				opIndexTuple += std::to_string(stride - 1);
				opIndexTuple += "]) / opStrides[";
				opIndexTuple += std::to_string(stride);
				opIndexTuple += "], ";
			}
		}
		opIndexTuple.erase(opIndexTuple.end() - 2, opIndexTuple.end()); // remove last ", "
		opIndexTuple += "};";

		file->PrintfLine("%s", opIndexTuple.c_str());
	}

	file->PrintfLine("%s sum = 0;", varOp->GetTypeString());
	for(uint32_t factorIndex = 0; factorIndex < contractValue->lfactors.size(); factorIndex++)
	{
		file->PrintfLine("for(int dim%u = 0; dim%u < %u; dim%u++)",
				factorIndex, factorIndex,
				argVec->__space_->factors_[argContractFactors->at(factorIndex)].dim_,
				factorIndex);
		file->PrintfLine("{");
		file->Indent();
	}

	uint32_t opIndex = 0;
	if(!argVecIsLeftArg)
	{
		opIndex = opVec->__space_->factors_.size() - (argVec->__space_->factors_.size() - argContractFactors->size());
	}

	std::string argIndexTuple = "const uint32_t argIndexTuple[] = {";
	for(uint32_t lDim = 0; lDim < argVec->__space_->factors_.size(); lDim++)
	{
		auto it = std::find(
				argContractFactors->begin(),
				argContractFactors->end(),
				lDim);

		if(it == argContractFactors->end())
		{
			argIndexTuple += "opIndexTuple[";
			argIndexTuple += std::to_string(opIndex);
			argIndexTuple += "], ";
			opIndex++;
		}
		else
		{
			argIndexTuple += "dim" + std::to_string(std::distance(argContractFactors->begin(), it));
			argIndexTuple += ", ";
		}
	}

	argIndexTuple.erase(argIndexTuple.end() - 2, argIndexTuple.end()); // remove last ", "
	argIndexTuple += "};";
	file->PrintfLine(argIndexTuple.c_str());

	if(!argVecIsLeftArg)
	{
		opIndex = 0;
	}

	std::string kronIndexTuple = "const uint32_t kronIndexTuple[] = {";
	for(uint32_t rDim = 0; rDim < kronVec->__space_->factors_.size(); rDim++)
	{
		auto it = std::find(
				kronContractFactors->begin(),
				kronContractFactors->end(),
				rDim);

		if(it == kronContractFactors->end())
		{
			kronIndexTuple += "opIndexTuple[";
			kronIndexTuple += std::to_string(opIndex);
			kronIndexTuple += "], ";
			opIndex++;
		}
		else
		{
			kronIndexTuple += "dim" + std::to_string(std::distance(kronContractFactors->begin(), it));
			kronIndexTuple += ", ";
		}
	}

	kronIndexTuple.erase(kronIndexTuple.end() - 2, kronIndexTuple.end()); // remove last ", "
	kronIndexTuple += "};";
	file->PrintfLine(kronIndexTuple.c_str());

	// A_ijk	= B_ijm d_mk
	//			= B_ijk
	//
	// A_ijkl	= B_ijmn d_ml d_nk
	//			= B_ijlk
	//
	// This is the weird case:
	// A_ijkl	= B_ijmn d_mn d_kl
	//			= B_ijnn d_kl

	std::string sum = "sum += ";
	sum += *(varArgVec->GetIdentifier()) + "[";
	for(uint32_t argIndex = 0; argIndex < argVec->__space_->factors_.size(); argIndex++)
	{
		sum += "argIndexTuple[" +
				std::to_string(argIndex) + "] * "
				+  argStridesId + "[" +  std::to_string(argIndex) + "] + ";
	}
	sum.erase(sum.end() - 3, sum.end()); // remove last " +"
	sum += "] *";

	for(size_t paramPos = 0; paramPos < kroneckerParam->DeltaPair.size(); paramPos++)
	{
		if(kroneckerParam->DeltaPair[paramPos] > paramPos) // Remember, we save the partner for every factor, but only half the information is needed
		{
			sum += " (kronIndexTuple[" + std::to_string(paramPos) + "] ==";
			sum += " kronIndexTuple[deltaPairs[" + std::to_string(paramPos) + "]]) *";
		}
	}
	sum += " " + std::to_string(kroneckerParam->Scaling) + "f;";

	file->PrintfLine(sum.c_str());

	for(uint32_t factorIndex = 0; factorIndex < contractValue->lfactors.size(); factorIndex++)
	{
		file->Outdent();
		file->PrintfLine("}");
	}

	file->PrintfLine("");

	if(resultIsArray)
	{
		file->PrintfLine("%s[opIndex] = sum;",
				varOpId);

		file->Outdent();
		file->PrintfLine("}");
	}
	else
	{
		file->PrintfLine("%s = sum;", varOpId);
	}

	return true;
}

bool CodeGenerator::VectorPermutationCode(const Node* node, FileWriter * file)
{
	file->PrintfLine("// %s\n", __func__);

	const Node::permuteParameters_t * permuteParam = (const Node::permuteParameters_t *) node->typeParameters;

	auto nodes = graph_->GetNodes();
	const auto argNode = nodes->find(node->parents[0]);
	if(nodes->end() == argNode)
	{
		Error("Could not find Node for id %u\n", node->parents[0]);
		return false;
	}

	const Algebra::Module::VectorSpace::Vector* vec = (const Algebra::Module::VectorSpace::Vector*) argNode->second.object;

	getVarRetFalseOnError(varOp, node->id);
	getVarRetFalseOnError(varArg, node->parents[0]);

	const char * varOpId = varOp->GetIdentifier()->c_str();
	const char * varArgId = varArg->GetIdentifier()->c_str();

	std::vector<uint32_t> strides;
	vec->__space_->GetStrides(&strides);
	const char stridesId[] = "strides";
	file->PrintfLine("const uint32_t %s[] = {", stridesId);
	for(const uint32_t &stride: strides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};\n");

	file->PrintfLine("for(size_t opIndex = 0; opIndex < sizeof(%s) / sizeof(%s[0]); opIndex++)",
			varOpId, varOpId);
	file->PrintfLine("{");
	file->Indent();

	std::string opIndexTuple = "const uint32_t opIndexTuple[] = {";
	for(uint32_t stride = 0; stride < strides.size(); stride++)
	{
		if(0 == stride)
		{
			opIndexTuple += "opIndex / ";
			opIndexTuple += stridesId;
			opIndexTuple += "[";
			opIndexTuple += std::to_string(stride);
			opIndexTuple += "]";
			opIndexTuple += ", ";
		}
		else
		{
			opIndexTuple += "(opIndex % strides[";
			opIndexTuple += std::to_string(stride - 1);
			opIndexTuple += "]) / strides[";
			opIndexTuple += std::to_string(stride);
			opIndexTuple += "], ";
		}
	}
	opIndexTuple.erase(opIndexTuple.end() - 2, opIndexTuple.end()); // remove last ", "
	opIndexTuple += "};";

	file->PrintfLine("%s", opIndexTuple.c_str());

	std::string argIndexTuple = "const uint32_t argIndexTuple[] = {";

	for(size_t argIndex = 0; argIndex < permuteParam->indices.size(); argIndex++)
	{
		argIndexTuple += "opIndexTuple[" + std::to_string(permuteParam->indices[argIndex]) + "], ";
	}

	argIndexTuple.erase(argIndexTuple.end() - 2, argIndexTuple.end()); // remove last ", "
	argIndexTuple += "};\n";

	file->PrintfLine("%s", argIndexTuple.c_str());

	std::string opValue = varOpId;
	opValue += "[opIndex]";
	opValue += " = ";
	opValue += varArgId;
	opValue += "[";

	for(size_t argIndex = 0; argIndex < vec->__space_->factors_.size(); argIndex++)
	{
		opValue += "argIndexTuple[" + std::to_string(argIndex) + "] * " + stridesId + "[" + std::to_string(argIndex) + "] + ";
	}
	opValue.erase(opValue.end() - 3, opValue.end()); // remove last " + "
	opValue += "];";

	file->PrintfLine("%s", opValue.c_str());

	file->Outdent();
	file->PrintfLine("}");

	return true;
}

bool CodeGenerator::VectorContractionCode(const Node* node, FileWriter * file)
{
	file->PrintfLine("// %s\n", __func__);

	auto nodes = graph_->GetNodes();
	const auto lnode = nodes->find(node->parents[0]);
	if(nodes->end() == lnode)
	{
		Error("Could not find Node for id %u\n", node->parents[0]);
		return false;
	}

	const auto rnode = nodes->find(node->parents[1]);
	if(nodes->end() == rnode)
	{
		Error("Could not find Node for id %u\n", node->parents[1]);
		return false;
	}

	if((Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT == lnode->second.type) ||
			(Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT == rnode->second.type))
	{
		return VectorContractionKroneckerDeltaCode(node, file);
	}

	getVarRetFalseOnError(varOp, node->id);
	getVarRetFalseOnError(varLVec, node->parents[0]);
	getVarRetFalseOnError(varRVec, node->parents[1]);

	const Algebra::Module::VectorSpace::Vector* lVec = (const Algebra::Module::VectorSpace::Vector*) lnode->second.object;
	const Algebra::Module::VectorSpace::Vector* rVec = (const Algebra::Module::VectorSpace::Vector*) rnode->second.object;

	const Algebra::Module::VectorSpace::Vector* opVec = (const Algebra::Module::VectorSpace::Vector*) node->object;
	const Node::contractParameters_t * contractValue = (Node::contractParameters_t *) node->typeParameters;

	// Calculate Strides, assume Row-Major Layout
	// https://en.wikipedia.org/wiki/Row-_and_column-major_order#Address_calculation_in_general
	std::vector<uint32_t> lStrides;
	lVec->__space_->GetStrides(&lStrides);
	const char lstridesId[] = "lStrides";
	file->PrintfLine("const uint32_t %s[] = {", lstridesId);
	for(const uint32_t &stride: lStrides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};");

	std::vector<uint32_t> rStrides;
	rVec->__space_->GetStrides(&rStrides);
	const char rstridesId[] = "rStrides";
	file->PrintfLine("const uint32_t %s[] = {", rstridesId);
	for(const uint32_t &stride: rStrides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};");

	const char * varOpId = varOp->GetIdentifier()->c_str();

	bool resultIsArray = (1 < varOp->Length());

	if(resultIsArray)
	{
		std::vector<uint32_t> opStrides;
		opVec->__space_->GetStrides(&opStrides);
		const char opstridesId[] = "opStrides";
		file->PrintfLine("const uint32_t %s[] = {", opstridesId);
		for(const uint32_t &stride: opStrides)
		{
			file->PrintfLine("\t %u,", stride);
		}
		file->PrintfLine("};\n");

		file->PrintfLine("for(size_t opIndex = 0; opIndex < sizeof(%s) / sizeof(%s[0]); opIndex++)",
				varOpId, varOpId);
		file->PrintfLine("{");
		file->Indent();

		std::string opIndexTuple = "const uint32_t opIndexTuple[] = {";
		for(uint32_t stride = 0; stride < opStrides.size(); stride++)
		{
			if(0 == stride)
			{
				opIndexTuple += "opIndex / ";
				opIndexTuple += opstridesId;
				opIndexTuple += "[";
				opIndexTuple += std::to_string(stride);
				opIndexTuple += "]";
				opIndexTuple += ", ";
			}
			else
			{
				opIndexTuple += "(opIndex % opStrides[";
				opIndexTuple += std::to_string(stride - 1);
				opIndexTuple += "]) / opStrides[";
				opIndexTuple += std::to_string(stride);
				opIndexTuple += "], ";
			}
		}
		opIndexTuple.erase(opIndexTuple.end() - 2, opIndexTuple.end()); // remove last ", "
		opIndexTuple += "};";

		file->PrintfLine("%s", opIndexTuple.c_str());
	}

	file->PrintfLine("%s sum = 0;", varOp->GetTypeString());
	for(uint32_t factorIndex = 0; factorIndex < contractValue->lfactors.size(); factorIndex++)
	{
		file->PrintfLine("for(int dim%u = 0; dim%u < %u; dim%u++)",
				factorIndex, factorIndex,
				lVec->__space_->factors_[contractValue->lfactors[factorIndex]].dim_,
				factorIndex);
		file->PrintfLine("{");
		file->Indent();
	}

	uint32_t opIndex = 0;
	std::string lIndexTuple = "const uint32_t lIndexTuple[] = {";
	for(uint32_t lDim = 0; lDim < lVec->__space_->factors_.size(); lDim++)
	{
		auto it = std::find(
				contractValue->lfactors.begin(),
				contractValue->lfactors.end(),
				lDim);

		if(it == contractValue->lfactors.end())
		{
			lIndexTuple += "opIndexTuple[";
			lIndexTuple += std::to_string(opIndex);
			lIndexTuple += "], ";
			opIndex++;
		}
		else
		{
			lIndexTuple += "dim" + std::to_string(std::distance(contractValue->lfactors.begin(), it));
			lIndexTuple += ", ";
		}
	}

	lIndexTuple.erase(lIndexTuple.end() - 2, lIndexTuple.end()); // remove last ", "
	lIndexTuple += "};";
	file->PrintfLine(lIndexTuple.c_str());

	std::string rIndexTuple = "const uint32_t rIndexTuple[] = {";
	for(uint32_t rDim = 0; rDim < rVec->__space_->factors_.size(); rDim++)
	{
		auto it = std::find(
				contractValue->rfactors.begin(),
				contractValue->rfactors.end(),
				rDim);

		if(it == contractValue->rfactors.end())
		{
			rIndexTuple += "opIndexTuple[";
			rIndexTuple += std::to_string(opIndex);
			rIndexTuple += "], ";
			opIndex++;
		}
		else
		{
			rIndexTuple += "dim" + std::to_string(std::distance(contractValue->rfactors.begin(), it));
			rIndexTuple += ", ";
		}
	}

	rIndexTuple.erase(rIndexTuple.end() - 2, rIndexTuple.end()); // remove last ", "
	rIndexTuple += "};";
	file->PrintfLine(rIndexTuple.c_str());

	std::string sum = "sum += ";
	sum += *(varLVec->GetIdentifier()) + "[";
	for(uint32_t lIndex = 0; lIndex < lVec->__space_->factors_.size(); lIndex++)
	{
		sum += "lIndexTuple[" +
				std::to_string(lIndex) + "] * "
				+  lstridesId + "[" +  std::to_string(lIndex) + "] + ";
	}
	sum.erase(sum.end() - 3, sum.end()); // remove last " +"
	sum += "]";

	sum += " * ";

	sum += *(varRVec->GetIdentifier()) + "[";
	for(uint32_t rIndex = 0; rIndex < rVec->__space_->factors_.size(); rIndex++)
	{
		sum += "rIndexTuple[" +
				std::to_string(rIndex) + "] * "
				+  rstridesId + "[" +  std::to_string(rIndex) + "] + ";
	}
	sum.erase(sum.end() - 3, sum.end()); // remove last " +"
	sum += "];";

	file->PrintfLine(sum.c_str());

	for(uint32_t factorIndex = 0; factorIndex < contractValue->lfactors.size(); factorIndex++)
	{
		file->Outdent();
		file->PrintfLine("}");
	}

	file->PrintfLine("");

	if(resultIsArray)
	{
		file->PrintfLine("%s[opIndex] = sum;",
				varOpId);

		file->Outdent();
		file->PrintfLine("}");
	}
	else
	{
		file->PrintfLine("%s = sum;", varOpId);
	}

	return true;
}

bool CodeGenerator::VectorComparisonIsSmallerCode(const Node* node, FileWriter * file)
{
	file->PrintfLine("// %s\n", __func__);

	// TODO: Create extra Norm-Nodes for this.
	getVarRetFalseOnError(varOp, node->id);
	getVarRetFalseOnError(varLVec, node->parents[0]);
	getVarRetFalseOnError(varRVec, node->parents[1]);

	std::string lNormId;
	lNormId += *(varLVec->GetIdentifier());
	lNormId += "Norm";
	lNormId += std::to_string(varLVec->GetNewRunningNumber());
	file->PrintfLine("%s %s = 0;",
			varLVec->GetTypeString(),
			lNormId.c_str());

	std::string rNormId;
	rNormId += *(varRVec->GetIdentifier());
	rNormId += "Norm";
	rNormId += std::to_string(varRVec->GetNewRunningNumber());
	file->PrintfLine("%s %s = 0;",
			varRVec->GetTypeString(),
			rNormId.c_str());

	std::string lArrayElem;
	varLVec->GetElement(&lArrayElem, "dim");

	file->PrintfLine("for(uint32_t dim = 0; dim < %u; dim++)",
			varLVec->Length());
	file->PrintfLine("{");
	file->PrintfLine("\t %s += %s * %s;",
			lNormId.c_str(),
			lArrayElem.c_str(), lArrayElem.c_str());
	file->PrintfLine("}\n");

	std::string rArrayElem;
	varRVec->GetElement(&rArrayElem, "dim");

	file->PrintfLine("for(uint32_t dim = 0; dim < %u; dim++)",
			varRVec->Length());
	file->PrintfLine("{");
	file->PrintfLine("\t %s += %s * %s;",
			rNormId.c_str(),
			rArrayElem.c_str(), rArrayElem.c_str());
	file->PrintfLine("}\n");

	retFalseOnFalse(GenerateLocalVariableDeclaration(varOp), "Could not generate Var. Decl.\n");

	file->PrintfLine("if(%s < %s)",
			lNormId.c_str(), rNormId.c_str());
	file->PrintfLine("{");
	file->PrintfLine("\t %s = 1;",
			varOp->GetIdentifier()->c_str());
	file->PrintfLine("}");
	file->PrintfLine("else");
	file->PrintfLine("{");
	file->PrintfLine("\t %s = 0;",
			varOp->GetIdentifier()->c_str());
	file->PrintfLine("}\n");

	return true;
}

bool CodeGenerator::GetRootAncestorInstructionPositions(std::set<uint32_t> * instructionPos, Node::Id_t child)
{
	// Get root ancestors. Those won't be instructions
	std::set<Node::Id_t> rootAncestors;
	bool success = graph_->GetRootAncestors(&rootAncestors, child);
	if(!success)
	{
		Error("Could not get root ancestors!\n");
		return false;
	}

	// Get all of rootAncestor's children
	std::set<Node::Id_t> rootAncesorChildren;
	for(const Node::Id_t &rootId: rootAncestors)
	{
		const Node * rootNode = graph_->GetNode(rootId);

		for(const Node::Id_t &rootChildId: rootNode->children)
		{
			rootAncesorChildren.insert(rootChildId);
		}
	}

	// Get all children who do not depend on non-root parents
	std::set<Node::Id_t> rootChildren;
	for(const Node::Id_t &childId: rootAncesorChildren)
	{
		const Node * rootNode = graph_->GetNode(childId);

		bool allParentsRoot = true;
		for(const Node::Id_t &parentId: rootNode->parents)
		{
			if(rootAncestors.end() == rootAncestors.find(parentId))
			{
				allParentsRoot = false;
				break;
			}
		}

		if(allParentsRoot)
		{
			rootChildren.insert(childId);
		}
	}

	for(const Node::Id_t rootChildId: rootChildren)
	{
		const auto &arrayPos = nodeArrayPos_.find(rootChildId);
		if(nodeArrayPos_.end() == arrayPos)
		{
			Error("Couldn't find array position for Node%u\n", rootChildId);
			return false;
		}

		instructionPos->insert(arrayPos->second);
	}

	return true;
}

bool CodeGenerator::ControlTransferWhileCode(const Node* node, FileWriter * file)
{
	file->PrintfLine("// %s\n", __func__);

	getVarRetFalseOnError(varCond, node->parents[0]);

	if(1 != varCond->Length())
	{
		Error("Control Transfer condition has more than one dim.!\n");
		return false;
	}

	const auto * ctWhile = (ControlTransfer::While*) node->object;

	std::set<uint32_t> arrayPosTrue;
	if(Node::ID_NONE != ctWhile->getTrueNode())
	{
		bool success = GetRootAncestorInstructionPositions(&arrayPosTrue, ctWhile->getTrueNode());
		if(!success)
		{
			Error("Could not get root ancestor instructions!\n");
			return false;
		}
	}

	std::set<uint32_t> arrayPosFalse;
	if(Node::ID_NONE != ctWhile->getFalseNode())
	{
		bool success = GetRootAncestorInstructionPositions(&arrayPosFalse, ctWhile->getFalseNode());
		if(!success)
		{
			Error("Could not get root ancestor instructions!\n");
			return false;
		}
	}

	// Add the condition to the instruction calculated when true
	std::set<uint32_t> arrayPosCondition;
	bool success = GetRootAncestorInstructionPositions(&arrayPosCondition, node->parents[0]);
	if(!success)
	{
		Error("Could not get root ancestor instructions!\n");
		return false;
	}

	arrayPosTrue.insert(arrayPosCondition.begin(), arrayPosCondition.end());

	// Print the instructions
	file->PrintfLine("if(%s)", varCond->GetIdentifier()->c_str());
	file->PrintfLine("{");

	if(arrayPosTrue.size())
	{
		for(const uint32_t &pos: arrayPosTrue)
		{
			file->PrintfLine("\tPushNode(instance, &nodes%s[%u]);",
					graph_->Name().c_str(),
					pos);
		}
	}
	else
	{
		file->PrintfLine("; // Do nothing");
	}

	file->PrintfLine("}");
	file->PrintfLine("else");
	file->PrintfLine("{");

	if(arrayPosFalse.size())
	{
		for(const uint32_t &pos: arrayPosFalse)
		{
			file->PrintfLine("\tPushNode(instance, &nodes%s[%u]);",
					graph_->Name().c_str(),
					pos);
		}
	}
	else
	{
		file->PrintfLine("\t; // Do nothing");
	}

	file->PrintfLine("}");

	return true;
}

bool CodeGenerator::VectorScalarProductKroneckerDeltaCode(const Node* node, FileWriter * file, bool divide)
{
	file->PrintfLine("// %s\n", __func__);

	auto nodes = graph_->GetNodes();
	const auto lVecNode = nodes->find(node->parents[0]);
	if(nodes->end() == lVecNode)
	{
		Error("Could not find Node for id %u\n", node->parents[0]);
		return false;
	}

	const auto rVecNode = nodes->find(node->parents[1]);
	if(nodes->end() == rVecNode)
	{
		Error("Could not find Node for id %u\n", node->parents[1]);
		return false;
	}

	Node::Id_t varScalarNodeId;
	const Node * kronNode = nullptr;
	if(Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT == lVecNode->second.type)
	{
		kronNode = &lVecNode->second;
		varScalarNodeId = node->parents[1];
	}
	else
	{
		kronNode = &rVecNode->second;

		if(divide)
		{
			Error("Can't divide by kronecker (division by zero)!\n");
			return false;
		}

		varScalarNodeId = node->parents[0];
	}

	getVarRetFalseOnError(varOp, node->id);
	getVarRetFalseOnError(varScalar, varScalarNodeId);

	const Algebra::Module::VectorSpace::KroneckerDeltaParameters_t * kroneckerParam = (const Algebra::Module::VectorSpace::KroneckerDeltaParameters_t *) kronNode->typeParameters;

	retFalseOnFalse(GenerateLocalVariableDeclaration(varOp), "Could not generate Var. Decl.\n");

	auto opVec = (const Algebra::Module::VectorSpace::Vector*) node->object;

	// TODO: This is a giant waste of resources: Every Node should have a "scaling" attached to it, so multiplication needs
	// to only be performed on that.

	std::vector<uint32_t> opStrides;
	opVec->__space_->GetStrides(&opStrides);
	const char opstridesId[] = "opStrides";
	file->PrintfLine("const uint32_t %s[] = {", opstridesId);
	for(const uint32_t &stride: opStrides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};\n");

	std::string deltaPairs = "const uint32_t deltaPairs[] = {";
	for(size_t paramPos = 0; paramPos < kroneckerParam->DeltaPair.size(); paramPos++)
	{
		deltaPairs += std::to_string(kroneckerParam->DeltaPair[paramPos]) + ", ";
	}
	deltaPairs.erase(deltaPairs.end() - 2, deltaPairs.end()); // remove last ", "
	deltaPairs += "};";
	file->PrintfLine("%s", deltaPairs.c_str());

	file->PrintfLine("for(uint32_t opIndex = 0; opIndex < %u; opIndex++)",
			opVec->__space_->GetDim());

	file->PrintfLine("{");
	file->Indent();

	std::string opIndexTuple = "const uint32_t opIndexTuple[] = {";
	for(uint32_t stride = 0; stride < opStrides.size(); stride++)
	{
		if(0 == stride)
		{
			opIndexTuple += "opIndex / ";
			opIndexTuple += opstridesId;
			opIndexTuple += "[";
			opIndexTuple += std::to_string(stride);
			opIndexTuple += "]";
			opIndexTuple += ", ";
		}
		else
		{
			opIndexTuple += "(opIndex % opStrides[";
			opIndexTuple += std::to_string(stride - 1);
			opIndexTuple += "]) / opStrides[";
			opIndexTuple += std::to_string(stride);
			opIndexTuple += "], ";
		}
	}
	opIndexTuple.erase(opIndexTuple.end() - 2, opIndexTuple.end()); // remove last ", "

	opIndexTuple += "};";

	file->PrintfLine("%s", opIndexTuple.c_str());

	std::string Result = *(varOp->GetIdentifier());
	Result += "[opIndex] =";
	for(size_t paramPos = 0; paramPos < kroneckerParam->DeltaPair.size(); paramPos++)
	{
		if(kroneckerParam->DeltaPair[paramPos] > paramPos) // Remember, we save the partner for every factor, but only half the information is needed
		{
			Result += " (opIndexTuple[" + std::to_string(paramPos) + "] ==";
			Result += " opIndexTuple[deltaPairs[" + std::to_string(paramPos) + "]]) *";
		}
	}
	Result += " " + std::to_string(kroneckerParam->Scaling) + "f";

	if(divide)
	{
		Result += " / ";
	}
	else
	{
		Result += " * ";
	}

	 Result += *varScalar->GetIdentifier() + ";";;

	file->PrintfLine(Result.c_str());

	file->Outdent();
	file->PrintfLine("}\n");

	return true;
}

bool CodeGenerator::VectorVectorProductKroneckerDeltaCode(const Node* node, FileWriter * file, bool divide)
{
	file->PrintfLine("// %s\n", __func__);

	auto nodes = graph_->GetNodes();

	const auto lnode = nodes->find(node->parents[0]);
	if(nodes->end() == lnode)
	{
		Error("Could not find Node for id %u\n", node->parents[0]);
		return false;
	}

	const auto rnode = nodes->find(node->parents[1]);
	if(nodes->end() == rnode)
	{
		Error("Could not find Node for id %u\n", node->parents[1]);
		return false;
	}

	bool lNodeIsKron = (Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT == lnode->second.type);
	bool rNodeIsKron = (Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT == rnode->second.type);

	if(lNodeIsKron && rNodeIsKron)
	{
		Error("Product of two KroneckerDeltas not supported: Should be handled in graph creation!\n");
		return false;
	}

	if(divide && rNodeIsKron)
	{
		Error("Can't divide by Kronecker (division by zero)!\n");
		return false;
	}

	Node::Id_t vecNodeId;
	const Algebra::Module::VectorSpace::Vector* vec;
	const Algebra::Module::VectorSpace::Vector* kronVec;
	const Algebra::Module::VectorSpace::KroneckerDeltaParameters_t * kroneckerParam;
	if(lNodeIsKron)
	{
		vecNodeId = node->parents[1];
		kronVec = (const Algebra::Module::VectorSpace::Vector*) lnode->second.object;
		vec = (const Algebra::Module::VectorSpace::Vector*) rnode->second.object;
		kroneckerParam = (const Algebra::Module::VectorSpace::KroneckerDeltaParameters_t *) lnode->second.typeParameters;
	}
	else
	{
		vecNodeId = node->parents[0];
		kronVec = (const Algebra::Module::VectorSpace::Vector*) rnode->second.object;
		vec = (const Algebra::Module::VectorSpace::Vector*) lnode->second.object;
		kroneckerParam = (const Algebra::Module::VectorSpace::KroneckerDeltaParameters_t *) rnode->second.typeParameters;
	}

	getVarRetFalseOnError(varOp, node->id);
	getVarRetFalseOnError(varVec, vecNodeId);

	const Algebra::Module::VectorSpace::Vector* opVec = (const Algebra::Module::VectorSpace::Vector*) node->object;

	// Calculate Strides, assume Row-Major Layout
	// https://en.wikipedia.org/wiki/Row-_and_column-major_order#Address_calculation_in_general
	std::vector<uint32_t> vecStrides;
	vec->__space_->GetStrides(&vecStrides);
	const char vecStridesId[] = "vecStrides";
	file->PrintfLine("const uint32_t %s[] = {", vecStridesId);
	for(const uint32_t &stride: vecStrides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};");

	std::vector<uint32_t> opStrides;
	opVec->__space_->GetStrides(&opStrides);
	const char opstridesId[] = "opStrides";
	file->PrintfLine("const uint32_t %s[] = {", opstridesId);
	for(const uint32_t &stride: opStrides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};\n");

	std::string deltaPairs = "const uint32_t deltaPairs[] = {";
	for(size_t paramPos = 0; paramPos < kroneckerParam->DeltaPair.size(); paramPos++)
	{
		deltaPairs += std::to_string(kroneckerParam->DeltaPair[paramPos]) + ", ";
	}
	deltaPairs.erase(deltaPairs.end() - 2, deltaPairs.end()); // remove last ", "
	deltaPairs += "};";
	file->PrintfLine("%s", deltaPairs.c_str());

	const char * varOpId = varOp->GetIdentifier()->c_str();

	file->PrintfLine("for(size_t opIndex = 0; opIndex < sizeof(%s) / sizeof(%s[0]); opIndex++)",
			varOpId, varOpId);
	file->PrintfLine("{");
	file->Indent();

	std::string opIndexTuple = "const uint32_t opIndexTuple[] = {";
	for(uint32_t stride = 0; stride < opStrides.size(); stride++)
	{
		if(0 == stride)
		{
			opIndexTuple += "opIndex / ";
			opIndexTuple += opstridesId;
			opIndexTuple += "[";
			opIndexTuple += std::to_string(stride);
			opIndexTuple += "]";
			opIndexTuple += ", ";
		}
		else
		{
			opIndexTuple += "(opIndex % opStrides[";
			opIndexTuple += std::to_string(stride - 1);
			opIndexTuple += "]) / opStrides[";
			opIndexTuple += std::to_string(stride);
			opIndexTuple += "], ";
		}
	}
	opIndexTuple.erase(opIndexTuple.end() - 2, opIndexTuple.end()); // remove last ", "
	opIndexTuple += "};";

	file->PrintfLine("%s", opIndexTuple.c_str());

	uint32_t vecIndexOffset = 0;
	if(lNodeIsKron)
	{
		vecIndexOffset = kronVec->__space_->factors_.size();
	}

	std::string vecIndexTuple = "const uint32_t vecIndexTuple[] = {";
	for(uint32_t lDim = 0; lDim < vec->__space_->factors_.size(); lDim++)
	{
		vecIndexTuple += "opIndexTuple[";
		vecIndexTuple += std::to_string(lDim + vecIndexOffset);
		vecIndexTuple += "], ";
	}

	vecIndexTuple.erase(vecIndexTuple.end() - 2, vecIndexTuple.end()); // remove last ", "
	vecIndexTuple += "};";
	file->PrintfLine(vecIndexTuple.c_str());

	uint32_t kronIndexOffset = vec->__space_->factors_.size();
	if(lNodeIsKron)
	{
		kronIndexOffset = 0;
	}

	std::string kronIndexTuple = "const uint32_t kronIndexTuple[] = {";
	for(uint32_t rDim = 0; rDim < kronVec->__space_->factors_.size(); rDim++)
	{
		kronIndexTuple += "opIndexTuple[";
		kronIndexTuple += std::to_string(rDim + kronIndexOffset);
		kronIndexTuple += "], ";
	}

	kronIndexTuple.erase(kronIndexTuple.end() - 2, kronIndexTuple.end()); // remove last ", "
	kronIndexTuple += "};";
	file->PrintfLine(kronIndexTuple.c_str());

	std::string product = varOpId;
	product += "[opIndex] =";

	for(size_t paramPos = 0; paramPos < kroneckerParam->DeltaPair.size(); paramPos++)
	{
		if(kroneckerParam->DeltaPair[paramPos] > paramPos) // Remember, we save the partner for every factor, but only half the information is needed
		{
			product += " (kronIndexTuple[" + std::to_string(paramPos) + "] ==";
			product += " kronIndexTuple[deltaPairs[" + std::to_string(paramPos) + "]]) *";
		}
	}
	product += " " + std::to_string(kroneckerParam->Scaling) + "f";

	if(divide)
	{
		product += " / ";
	}
	else
	{
		product += " * ";
	}

	product += *(varVec->GetIdentifier()) + "[";
	for(uint32_t lIndex = 0; lIndex < vec->__space_->factors_.size(); lIndex++)
	{
		product += "vecIndexTuple[" +
				std::to_string(lIndex) + "] * "
				+  vecStridesId + "[" +  std::to_string(lIndex) + "] + ";
	}
	product.erase(product.end() - 3, product.end()); // remove last " +"
	product += "];";

	file->PrintfLine(product.c_str());

	file->PrintfLine("");

	file->Outdent();
	file->PrintfLine("}");

	return true;
}

bool CodeGenerator::VectorVectorProductCode(const Node* node, FileWriter * file, bool divide)
{
	file->PrintfLine("// %s\n", __func__);

	auto nodes = graph_->GetNodes();

	const auto lnode = nodes->find(node->parents[0]);
	if(nodes->end() == lnode)
	{
		Error("Could not find Node for id %u\n", node->parents[0]);
		return false;
	}

	const auto rnode = nodes->find(node->parents[1]);
	if(nodes->end() == rnode)
	{
		Error("Could not find Node for id %u\n", node->parents[1]);
		return false;
	}

	if((Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT == lnode->second.type) ||
			(Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT == rnode->second.type))
	{
		return VectorVectorProductKroneckerDeltaCode(node, file, divide);
	}

	getVarRetFalseOnError(varOp, node->id);
	getVarRetFalseOnError(varLVec, node->parents[0]);
	getVarRetFalseOnError(varRVec, node->parents[1]);

	const Algebra::Module::VectorSpace::Vector* lVec = (const Algebra::Module::VectorSpace::Vector*) lnode->second.object;
	const Algebra::Module::VectorSpace::Vector* rVec = (const Algebra::Module::VectorSpace::Vector*) rnode->second.object;

	const Algebra::Module::VectorSpace::Vector* opVec = (const Algebra::Module::VectorSpace::Vector*) node->object;

	// Calculate Strides, assume Row-Major Layout
	// https://en.wikipedia.org/wiki/Row-_and_column-major_order#Address_calculation_in_general
	std::vector<uint32_t> lStrides;
	lVec->__space_->GetStrides(&lStrides);
	const char lstridesId[] = "lStrides";
	file->PrintfLine("const uint32_t %s[] = {", lstridesId);
	for(const uint32_t &stride: lStrides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};");

	std::vector<uint32_t> rStrides;
	rVec->__space_->GetStrides(&rStrides);
	const char rstridesId[] = "rStrides";
	file->PrintfLine("const uint32_t %s[] = {", rstridesId);
	for(const uint32_t &stride: rStrides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};");

	std::vector<uint32_t> opStrides;
	opVec->__space_->GetStrides(&opStrides);
	const char opstridesId[] = "opStrides";
	file->PrintfLine("const uint32_t %s[] = {", opstridesId);
	for(const uint32_t &stride: opStrides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};\n");

	const char * varOpId = varOp->GetIdentifier()->c_str();

	file->PrintfLine("for(size_t opIndex = 0; opIndex < sizeof(%s) / sizeof(%s[0]); opIndex++)",
			varOpId, varOpId);
	file->PrintfLine("{");
	file->Indent();

	std::string opIndexTuple = "const uint32_t opIndexTuple[] = {";
	for(uint32_t stride = 0; stride < opStrides.size(); stride++)
	{
		if(0 == stride)
		{
			opIndexTuple += "opIndex / ";
			opIndexTuple += opstridesId;
			opIndexTuple += "[";
			opIndexTuple += std::to_string(stride);
			opIndexTuple += "]";
			opIndexTuple += ", ";
		}
		else
		{
			opIndexTuple += "(opIndex % opStrides[";
			opIndexTuple += std::to_string(stride - 1);
			opIndexTuple += "]) / opStrides[";
			opIndexTuple += std::to_string(stride);
			opIndexTuple += "], ";
		}
	}
	opIndexTuple.erase(opIndexTuple.end() - 2, opIndexTuple.end()); // remove last ", "
	opIndexTuple += "};";

	file->PrintfLine("%s", opIndexTuple.c_str());

	std::string lIndexTuple = "const uint32_t lIndexTuple[] = {";
	for(uint32_t lDim = 0; lDim < lVec->__space_->factors_.size(); lDim++)
	{
		lIndexTuple += "opIndexTuple[";
		lIndexTuple += std::to_string(lDim);
		lIndexTuple += "], ";
	}

	lIndexTuple.erase(lIndexTuple.end() - 2, lIndexTuple.end()); // remove last ", "
	lIndexTuple += "};";
	file->PrintfLine(lIndexTuple.c_str());

	std::string rIndexTuple = "const uint32_t rIndexTuple[] = {";
	for(uint32_t rDim = 0; rDim < rVec->__space_->factors_.size(); rDim++)
	{
		rIndexTuple += "opIndexTuple[";
		rIndexTuple += std::to_string(rDim + lVec->__space_->factors_.size());
		rIndexTuple += "], ";
	}

	rIndexTuple.erase(rIndexTuple.end() - 2, rIndexTuple.end()); // remove last ", "
	rIndexTuple += "};";
	file->PrintfLine(rIndexTuple.c_str());

	std::string product = varOpId;
	product += "[opIndex] = ";
	product += *(varLVec->GetIdentifier()) + "[";
	for(uint32_t lIndex = 0; lIndex < lVec->__space_->factors_.size(); lIndex++)
	{
		product += "lIndexTuple[" +
				std::to_string(lIndex) + "] * "
				+  lstridesId + "[" +  std::to_string(lIndex) + "] + ";
	}
	product.erase(product.end() - 3, product.end()); // remove last " +"
	product += "]";

	if(divide)
	{
		product += " / ";
	}
	else
	{
		product += " * ";
	}

	product += *(varRVec->GetIdentifier()) + "[";
	for(uint32_t rIndex = 0; rIndex < rVec->__space_->factors_.size(); rIndex++)
	{
		product += "rIndexTuple[" +
				std::to_string(rIndex) + "] * "
				+  rstridesId + "[" +  std::to_string(rIndex) + "] + ";
	}
	product.erase(product.end() - 3, product.end()); // remove last " +"
	product += "];";

	file->PrintfLine(product.c_str());

	file->PrintfLine("");

	file->Outdent();
	file->PrintfLine("}");

	return true;
}

bool CodeGenerator::VectorJoinIndicesCode(const Node* node, FileWriter * file)
{
	file->PrintfLine("// %s\n", __func__);

	auto nodes = graph_->GetNodes();

	const Node::joinIndicesParameters_t * param = (Node::joinIndicesParameters_t *) node->typeParameters;

	getVarRetFalseOnError(varOp, node->id);
	getVarRetFalseOnError(varArg, node->parents[0]);

	const auto argNode = nodes->find(node->parents[0]);
	if(nodes->end() == argNode)
	{
		Error("Could not find Node for id %u\n", node->parents[0]);
		return false;
	}

	const Algebra::Module::VectorSpace::Vector* vecArg = (const Algebra::Module::VectorSpace::Vector*) argNode->second.object;
	const Algebra::Module::VectorSpace::Vector* vecOp = (const Algebra::Module::VectorSpace::Vector*) node->object;

	std::vector<uint32_t> opStrides;
	vecOp->__space_->GetStrides(&opStrides);
	const char opstridesId[] = "opStrides";
	file->PrintfLine("const uint32_t %s[] = {", opstridesId);
	for(const uint32_t &stride: opStrides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};\n");

	std::vector<uint32_t> argStrides;
	vecArg->__space_->GetStrides(&argStrides);
	const char argstridesId[] = "argStrides";
	file->PrintfLine("const uint32_t %s[] = {", argstridesId);
	for(const uint32_t &stride: argStrides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};");

	file->PrintfLine("for(size_t opIndex = 0; opIndex < sizeof(%s) / sizeof(%s[0]); opIndex++)",
			varOp->GetIdentifier()->c_str(), varOp->GetIdentifier()->c_str());
	file->PrintfLine("{");
	file->Indent();

	std::string opIndexTuple = "const uint32_t opIndexTuple[] = {";
	for(uint32_t stride = 0; stride < opStrides.size(); stride++)
	{
		if(0 == stride)
		{
			opIndexTuple += "opIndex / ";
			opIndexTuple += opstridesId;
			opIndexTuple += "[";
			opIndexTuple += std::to_string(stride);
			opIndexTuple += "]";
			opIndexTuple += ", ";
		}
		else
		{
			opIndexTuple += "(opIndex % opStrides[";
			opIndexTuple += std::to_string(stride - 1);
			opIndexTuple += "]) / opStrides[";
			opIndexTuple += std::to_string(stride);
			opIndexTuple += "], ";
		}
	}
	opIndexTuple.erase(opIndexTuple.end() - 2, opIndexTuple.end()); // remove last ", "
	opIndexTuple += "};";

	file->PrintfLine("%s", opIndexTuple.c_str());

	std::vector<uint32_t> opIndexPos(param->Indices.size(), UINT32_MAX);
	std::string argIndexTuple = "const uint32_t argIndexTuple[] = {";
	for(uint32_t dim = 0; dim < vecArg->__space_->factors_.size(); dim++)
	{
		argIndexTuple += "opIndexTuple[";

		// Is the factor joined?
		size_t joinedIndices;
		for(joinedIndices = 0; joinedIndices < param->Indices.size(); joinedIndices++)
		{
			auto it = std::find(param->Indices[joinedIndices].begin(), param->Indices[joinedIndices].end(), dim);

			if(param->Indices[joinedIndices].end() != it) // Index is joined
			{
				if(param->Indices[joinedIndices].begin() == it) // Set op position of this index
				{
					opIndexPos[joinedIndices] = dim;
				}

				break; // Found index, no need to search further.
			}
		}

		if(param->Indices.size() <= joinedIndices) // index not joined
		{
			argIndexTuple += std::to_string(dim);
		}
		else
		{
			argIndexTuple += std::to_string(opIndexPos[joinedIndices]);
		}

		argIndexTuple += "], ";
	}

	argIndexTuple.erase(argIndexTuple.end() - 2, argIndexTuple.end()); // remove last ", "
	argIndexTuple += "};\n";
	file->PrintfLine(argIndexTuple.c_str());

	std::string equationStr = *varOp->GetIdentifier() + "[opIndex] = ";
	equationStr += *varArg->GetIdentifier() + "[";

	for(uint32_t argIndex = 0; argIndex < vecArg->__space_->factors_.size(); argIndex++)
	{
		equationStr += "argIndexTuple[" +
				std::to_string(argIndex) + "] * "
				+  argstridesId + "[" +  std::to_string(argIndex) + "] + ";
	}
	equationStr.erase(equationStr.end() - 3, equationStr.end()); // remove last " +"
	equationStr += "];";

	file->PrintfLine(equationStr.c_str());

	file->Outdent();
	file->PrintfLine("}");

	return true;
}

bool CodeGenerator::VectorProjectionCode(const Node* node, FileWriter * file)
{
	file->PrintfLine("// %s\n", __func__);

	auto nodes = graph_->GetNodes();

	const Node::projectParameters_t * param = (const Node::projectParameters_t *) node->typeParameters;

	getVarRetFalseOnError(varOp, node->id);
	getVarRetFalseOnError(varArg, node->parents[0]);

	const auto argNode = nodes->find(node->parents[0]);
	if(nodes->end() == argNode)
	{
		Error("Could not find Node for id %u\n", node->parents[0]);
		return false;
	}

	const Algebra::Module::VectorSpace::Vector* vecArg = (const Algebra::Module::VectorSpace::Vector*) argNode->second.object;
	const Algebra::Module::VectorSpace::Vector* vecOp = (const Algebra::Module::VectorSpace::Vector*) node->object;

	std::vector<uint32_t> opStrides;
	vecOp->__space_->GetStrides(&opStrides);
	const char opstridesId[] = "opStrides";
	file->PrintfLine("const uint32_t %s[] = {", opstridesId);
	for(const uint32_t &stride: opStrides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};\n");

	std::vector<uint32_t> argStrides;
	vecArg->__space_->GetStrides(&argStrides);
	const char argstridesId[] = "argStrides";
	file->PrintfLine("const uint32_t %s[] = {", argstridesId);
	for(const uint32_t &stride: argStrides)
	{
		file->PrintfLine("\t %u,", stride);
	}
	file->PrintfLine("};");

	file->PrintfLine("for(size_t opIndex = 0; opIndex < sizeof(%s) / sizeof(%s[0]); opIndex++)",
			varOp->GetIdentifier()->c_str(), varOp->GetIdentifier()->c_str());
	file->PrintfLine("{");
	file->Indent();

	std::string opIndexTuple = "const uint32_t opIndexTuple[] = {";
	for(uint32_t stride = 0; stride < opStrides.size(); stride++)
	{
		if(0 == stride)
		{
			opIndexTuple += "opIndex / ";
			opIndexTuple += opstridesId;
			opIndexTuple += "[";
			opIndexTuple += std::to_string(stride);
			opIndexTuple += "]";
			opIndexTuple += ", ";
		}
		else
		{
			opIndexTuple += "(opIndex % opStrides[";
			opIndexTuple += std::to_string(stride - 1);
			opIndexTuple += "]) / opStrides[";
			opIndexTuple += std::to_string(stride);
			opIndexTuple += "], ";
		}
	}
	opIndexTuple.erase(opIndexTuple.end() - 2, opIndexTuple.end()); // remove last ", "
	opIndexTuple += "};";

	file->PrintfLine("%s", opIndexTuple.c_str());

	std::string argIndexTuple = "const uint32_t argIndexTuple[] = {";
	for(uint32_t dim = 0; dim < vecArg->__space_->factors_.size(); dim++)
	{
		argIndexTuple += "opIndexTuple[";
		argIndexTuple += std::to_string(dim);
		argIndexTuple += "]";

		if(0 != param->range[dim].first)
		{
			argIndexTuple += " + " + std::to_string(param->range[dim].first);
		}

		argIndexTuple += ", ";
	}

	argIndexTuple.erase(argIndexTuple.end() - 2, argIndexTuple.end()); // remove last ", "
	argIndexTuple += "};\n";
	file->PrintfLine(argIndexTuple.c_str());

	std::string equationStr = *varOp->GetIdentifier() + "[opIndex] = ";
	equationStr += *varArg->GetIdentifier() + "[";

	for(uint32_t argIndex = 0; argIndex < vecArg->__space_->factors_.size(); argIndex++)
	{
		equationStr += "argIndexTuple[" +
				std::to_string(argIndex) + "] * "
				+  argstridesId + "[" +  std::to_string(argIndex) + "] + ";
	}
	equationStr.erase(equationStr.end() - 3, equationStr.end()); // remove last " +"
	equationStr += "];";

	file->PrintfLine(equationStr.c_str());

	file->Outdent();
	file->PrintfLine("}");

	return true;
}

bool CodeGenerator::VectorPowerCode(const Node* node, FileWriter * file)
{
	file->PrintfLine("// %s\n", __func__);

	getVarRetFalseOnError(varOp, node->id);
	getVarRetFalseOnError(lVar, node->parents[0]);
	getVarRetFalseOnError(rVar, node->parents[1]);

	retFalseOnFalse(GenerateLocalVariableDeclaration(varOp), "Could not generate Var. Decl.\n");

	bool lVarIsScalar = (1 == lVar->Length());
	bool rVarIsScalar = (1 == rVar->Length());

	if(!rVarIsScalar)
	{
		Error("Can't take to non-scalar powers!\n");
		return false;
	}

	// TODO: If the exponent is a constant, it's probably faster to use sqrt in case of 0.5 and so forth
	const char powFunctions[][6] =
	{
			"powf",
			"pow",
			"powl"
	};

	const char* powFctString;
	switch(lVar->GetType())
	{
	case Variable::Type::uint8_: // no break intended
	case Variable::Type::int8_: // no break intended
	case Variable::Type::int32_: // no break intended
		// TODO: Implement https://en.wikipedia.org/wiki/Exponentiation_by_squaring
	case Variable::Type::float_:
		powFctString = powFunctions[0];
		break;

	default: // no break intended
	case Variable::Type::none: // no break intended
	case Variable::Type::nrOf:
		Error("Reached default case!\n");
		return false;
	}

	if(lVarIsScalar)
	{
		file->PrintfLine("%s = %s(%s, %s);",
				varOp->GetIdentifier()->c_str(),
				powFctString,
				lVar->GetIdentifier()->c_str(),
				rVar->GetIdentifier()->c_str());

		return true;
	}

	file->PrintfLine("for(size_t opIndex = 0; opIndex < sizeof(%s) / sizeof(%s[0]); opIndex++)",
			varOp->GetIdentifier()->c_str(), varOp->GetIdentifier()->c_str());
	file->PrintfLine("{");
	file->Indent();

	file->PrintfLine("%s[%s] = %s(%s[%s], %s);",
			varOp->GetIdentifier()->c_str(),
			"opIndex",
			powFctString,
			lVar->GetIdentifier()->c_str(),
			"opIndex",
			rVar->GetIdentifier()->c_str());

	file->Outdent();
	file->PrintfLine("}");

	return true;
}

bool CodeGenerator::VectorScalarProductCode(const Node* node, FileWriter * file, bool divide)
{
	file->PrintfLine("// %s\n", __func__);

	auto nodes = graph_->GetNodes();

	const auto lVecNode = nodes->find(node->parents[0]);
	if(nodes->end() == lVecNode)
	{
		Error("Could not find Node for id %u\n", node->parents[0]);
		return false;
	}

	const auto rVecNode = nodes->find(node->parents[1]);
	if(nodes->end() == rVecNode)
	{
		Error("Could not find Node for id %u\n", node->parents[1]);
		return false;
	}

	if((Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT == lVecNode->second.type) ||
			(Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT == rVecNode->second.type))
	{
		return VectorScalarProductKroneckerDeltaCode(node, file, divide);
	}

	getVarRetFalseOnError(varOp, node->id);
	getVarRetFalseOnError(lVar, node->parents[0]);
	getVarRetFalseOnError(rVar, node->parents[1]);

	retFalseOnFalse(GenerateLocalVariableDeclaration(varOp), "Could not generate Var. Decl.\n");

	auto vecOp = (const Algebra::Module::VectorSpace::Vector*) node->object;

	bool lVarIsScalar = (1 == lVar->Length());
	bool rVarIsScalar = (1 == rVar->Length());

	if(!lVarIsScalar || !rVarIsScalar)
	{
		file->PrintfLine("for(uint32_t dim = 0; dim < %u; dim++)",
				vecOp->__space_->GetDim());

		file->PrintfLine("{");
		file->Indent();
	}

	if(divide)
	{
		if(lVarIsScalar && rVarIsScalar)
		{
			file->PrintfLine("%s = %s / %s;",
					varOp->GetIdentifier()->c_str(),
					lVar->GetIdentifier()->c_str(),
					rVar->GetIdentifier()->c_str());
		}
		else if(lVarIsScalar)
		{
			file->PrintfLine("%s[dim] = %s / %s[dim];",
					varOp->GetIdentifier()->c_str(),
					lVar->GetIdentifier()->c_str(),
					rVar->GetIdentifier()->c_str());
		}
		else
		{
			file->PrintfLine("%s[dim] = %s[dim] / %s;",
					varOp->GetIdentifier()->c_str(),
					lVar->GetIdentifier()->c_str(),
					rVar->GetIdentifier()->c_str());
		}
	}
	else
	{
		if(lVarIsScalar && rVarIsScalar)
		{
			file->PrintfLine("%s = %s * %s;",
					varOp->GetIdentifier()->c_str(),
					lVar->GetIdentifier()->c_str(),
					rVar->GetIdentifier()->c_str());
		}
		else if(lVarIsScalar)
		{
			file->PrintfLine("%s[dim] = %s * %s[dim];",
					varOp->GetIdentifier()->c_str(),
					lVar->GetIdentifier()->c_str(),
					rVar->GetIdentifier()->c_str());
		}
		else
		{
			file->PrintfLine("%s[dim] = %s[dim] * %s;",
					varOp->GetIdentifier()->c_str(),
					lVar->GetIdentifier()->c_str(),
					rVar->GetIdentifier()->c_str());
		}
	}

	if(!lVarIsScalar || !rVarIsScalar)
	{
		file->Outdent();
		file->PrintfLine("}\n");
	}

	return true;
}

bool CodeGenerator::GenerateConstantDeclarations()
{
	for(const std::pair<Node::Id_t, Variable> &varPair: variables_)
	{
		const Variable * var = &varPair.second;
		if(var->HasProperty(Variable::PROPERTY_GLOBAL) && var->HasProperty(Variable::PROPERTY_CONST))
		{
			std::string decl;
			retFalseOnFalse(var->GetDeclaration(&decl), "Could not get declaration!\n");

			fileInstructions_.PrintfLine("%s", decl.c_str());
		}
	}

	return true;
}

bool CodeGenerator::GenerateStaticVariableDeclarations()
{
	for(const std::pair<Node::Id_t, Variable> &varPair: variables_)
	{
		const Variable * var = &varPair.second;
		if(var->HasProperty(Variable::PROPERTY_CONST))
		{
			// Constants are handled in another function
			continue;
		}

		if(var->HasProperty(Variable::PROPERTY_GLOBAL) && var->HasProperty(Variable::PROPERTY_STATIC))
		{
			std::string decl;
			retFalseOnFalse(var->GetDeclaration(&decl), "Could not get declaration!\n");

			fileInstructions_.PrintfLine("%s", decl.c_str());
		}
	}

	return true;
}

Variable* CodeGenerator::GetVariable(Node::Id_t id)
{
	auto nodes = graph_->GetNodes();
	const auto nodeIt = nodes->find(id);
	if(nodes->end() == nodeIt)
	{
		Error("Could not find Node for id %u\n", id);
		return nullptr;
	}

	Node::Id_t storageNodeId;
	if(Node::ID_NONE != nodeIt->second.storedIn_)
	{
		storageNodeId = nodeIt->second.storedIn_;
	}
	else
	{
		storageNodeId = id;
	}

	auto varIt = variables_.find(storageNodeId);
	if(variables_.end() == varIt)
	{
		Error("Node %u does not have a variable!\n", storageNodeId);
		return nullptr;
	}

	return &varIt->second;
}

bool CodeGenerator::FetchVariables()
{
	// Fetch all variables
	auto nodes = graph_->GetNodes();
	for(const auto &nodePair: *nodes)
	{
		if(nodePair.second.noStorage_ || (Node::ID_NONE != nodePair.second.storedIn_))
		{
			continue; // This node is not stored in its own variable or doesn't require storage
		}

		std::string identifier;
		Variable::properties_t properties = Variable::PROPERTY_NONE;
		Variable::Type type = Variable::Type::none;
		size_t length = 1;
		const void * value;

		char tmpIdStr[42];
		SNPRINTF(tmpIdStr, sizeof(tmpIdStr), "Node%u", nodePair.second.id);
		identifier.append(tmpIdStr);

		switch(nodePair.second.objectType)
		{
		case Node::ObjectType::MODULE_VECTORSPACE_VECTOR:
		{
			if(Node::Type::VECTOR_KRONECKER_DELTA_PRODUCT == nodePair.second.type)
			{
				continue; // doesn't require variable.
			}

			auto vector = (const Algebra::Module::VectorSpace::Vector*) nodePair.second.object;

			value = vector->__value_;
			length = vector->__space_->GetDim();
			switch(vector->__space_->GetRing())
			{
			case Algebra::Ring::Float32:
				type = Variable::Type::float_;
				break;

			case Algebra::Ring::Int32:
				type = Variable::Type::int32_;
				break;

			case Algebra::Ring::None: // no break intended
			default:
				Error("Unknown Ring %u!\n", vector->__space_->GetRing());
				return false;
			}

			if(nullptr != vector->__value_)
			{
				properties = (Variable::properties_t) (
						properties |
						Variable::PROPERTY_GLOBAL |
						Variable::PROPERTY_STATIC |
						Variable::PROPERTY_CONST);
			}
		}
		break;

		case Node::ObjectType::NONE: // no break intended
		case Node::ObjectType::INTERFACE_OUTPUT: // no break intended
		case Node::ObjectType::CONTROL_TRANSFER_WHILE:
			// No variable to create.
			continue;

		default:
			Error("Unknown ObjectType!\n");
			return false;
		}

		if(variables_.end() != variables_.find(nodePair.second.id))
		{
			Error("Variable already exists!\n");
			return false;
		}

		if(nodePair.second.usedAsStorageBy_.size())
		{
			properties = (Variable::properties_t) (
					properties & ~Variable::PROPERTY_CONST);
		}

		variables_.insert(
				std::make_pair(
						nodePair.second.id,
						Variable(&identifier, properties, type, length, value)));
	}

	// Identify Outputs and mark output variables as such
	for(const auto &nodePair: *nodes)
	{
		if(Node::Type::OUTPUT != nodePair.second.type)
		{
			continue;
		}

		// Find all variables of the output's parents, i.e. the nodes that
		// shall be output
		for(const auto &potparnodePair: *nodes)
		{
			for(const Node::Id_t &parentNodeId: potparnodePair.second.parents)
			{
				if(parentNodeId != potparnodePair.second.id)
				{
					continue;
				}

				getVarRetFalseOnError(var, parentNodeId);
				var->AddProperty(Variable::PROPERTY_GLOBAL);
				var->AddProperty(Variable::PROPERTY_STATIC);
			}
		}
	}

	// TODO: Identify constant variables!

	// TODO: Making all variables global and static so threads may use them easily for now
	for(auto &var: variables_)
	{
		var.second.AddProperty(Variable::PROPERTY_GLOBAL);
		var.second.AddProperty(Variable::PROPERTY_STATIC);
	}

	return true;
}

bool CodeGenerator::GenerateOutputFunctions()
{
	std::string fctDefinitions;

	auto nodes = graph_->GetNodes();
	for(const auto &nodePair: *nodes)
	{
		if(Node::Type::OUTPUT != nodePair.second.type)
		{
			continue;
		}

		auto * output = (const Interface::Output* ) nodePair.second.object;

		// Get Variable attached to node
		getVarRetFalseOnError(var, nodePair.second.parents[0]);

		std::string fctPtTypeId = "Dac" + graph_->Name() + "OutputCallback";
		fctPtTypeId += *(output->GetOutputName());

		std::string callbackTypedef;
		callbackTypedef += "typedef void (*";
		callbackTypedef += fctPtTypeId;
		callbackTypedef += "_t)(";
		callbackTypedef += "const ";
		callbackTypedef += var->GetTypeString();
		callbackTypedef += "* pt, size_t size);";

		// Export function prototype
		fileDacH_.PrintfLine("%s", callbackTypedef.c_str());
		fileDacH_.PrintfLine("extern void %s_Register(%s_t callback);",
				fctPtTypeId.c_str(),
				fctPtTypeId.c_str());

		// Declare Static Variables keeping the callback pointers
		fileDacC_.PrintfLine("%s_t %s = NULL;",
				fctPtTypeId.c_str(),
				fctPtTypeId.c_str());

		fileInstructions_.PrintfLine("extern %s_t %s;",
				fctPtTypeId.c_str(),
				fctPtTypeId.c_str());

		// Define Function
		char tmpBuff[200];
		SNPRINTF(tmpBuff, sizeof(tmpBuff), "void %s_Register(%s_t callback)\n{\n",
				fctPtTypeId.c_str(),
				fctPtTypeId.c_str());

		fctDefinitions += tmpBuff;

		SNPRINTF(tmpBuff, sizeof(tmpBuff), "\t %s = callback;\n", fctPtTypeId.c_str());
		fctDefinitions += tmpBuff;
		fctDefinitions += "}\n\n";
	}

	fileDacC_.PrintfLine("");

	auto exportedHeading = std::string("Exported Functions");
	retFalseOnFalse(GenerateHeading(&exportedHeading), "Exported Heading failed!\n");

	fileDacC_.PrintfLine("%s", fctDefinitions.c_str());

	return true;
}

bool CodeGenerator::GenerateHeading(const std::string * heading)
{
	const uint16_t headingWidth = 100;

	std::string starSpangledHeading;
	starSpangledHeading.reserve(headingWidth);

	starSpangledHeading += "\n/* ";
	starSpangledHeading += *heading;
	starSpangledHeading += " ";

	while(headingWidth > starSpangledHeading.length())
	{
		starSpangledHeading += "*";
	}

	fileDacC_.PrintfLine("%s*/", starSpangledHeading.c_str());

	return true;
}

bool CodeGenerator::GenerateIncludes()
{
	for(uint16_t incl = 0; incl < sizeof(includeFilesBrackets) / sizeof(includeFilesBrackets[0]); incl++)
	{
		fileDacC_.PrintfLine("#include <%s>", includeFilesBrackets[incl]);
	}

	fileDacC_.PrintfLine("\n");

	fileDacC_.PrintfLine("#include \"error_functions.h\"\n");
	fileDacC_.PrintfLine("#include \"Instructions%s.h\"\n", graph_->Name().c_str());
	fileDacC_.PrintfLine("#include \"Dac%s.h\"\n", graph_->Name().c_str());

	return true;
}

inline bool Variable::HasProperty(properties_t property) const
{
	if(properties_ & property)
	{
		return true;
	}

	return false;
}

Variable::Type Variable::GetType() const
{
	return type_;
}

const char* Variable::GetTypeString() const
{
	static const char typeStrings[(int) Type::nrOf][30] = {
			"0000", // make sure it throws error
			"uint8_t",
			"int8_t",
			"int32_t",
			"float",
	};

	switch(type_)
	{
	case Type::uint8_:
		return typeStrings[(int) Type::uint8_];

	case Type::int8_:
		return typeStrings[(int) Type::int8_];

	case Type::int32_:
		return typeStrings[(int) Type::int32_];
		break;

	case Type::float_:
		return typeStrings[(int) Type::float_];

	default: // no break intended
	case Type::none:
		Error("Unknown Type %u!\n", (unsigned int) type_);
		return nullptr;
	}

	return nullptr; // should not be reached
}

bool Variable::AddProperty(properties_t property)
{
	switch(property)
	{
	case PROPERTY_CONST: // no break intended
	case PROPERTY_STATIC: // no break intended
	case PROPERTY_GLOBAL:
		break;

	default:
		Error("Unknown property!\n");
		return false;
	}

	properties_ = (properties_t) (properties_ | property);

	return true;
}

Variable::Variable(const std::string* identifier, properties_t properties, Type type, size_t length, const void* value)
{
	value_ = value;

	if(PROPERTY_END_OF_ENUM <= properties)
	{
		Error("Unknown properties specified!\n");
		return;
	}
	properties_ = properties;

	type_ = type;
	length_ = length;

	if(nullptr == identifier)
	{
		Error("Nullpointer!\n");
		return;
	}

	identifier_ = *identifier;
}

bool Variable::GetDeclaration(std::string* decl) const
{
	if(properties_ & PROPERTY_STATIC)
	{
		decl->append("static ");
	}

	if(properties_ & PROPERTY_CONST)
	{
		decl->append("const ");
	}

	const char* typeStr = GetTypeString();
	if(nullptr == typeStr)
	{
		Error("Unknown type!\n");
		return false;
	}

	decl->append(typeStr);
	decl->append(" ");

	if(0 == identifier_.length())
	{
		Error("Identifier not set!\n");
		return false;
	}

	decl->append(identifier_);

	if(1 < length_) // this is an array
	{
		char tmpBuff[40];
		SNPRINTF(tmpBuff, sizeof(tmpBuff), "[%lu]", length_);
		decl->append(tmpBuff);
	}

	// Any initializer supplied?
	if(properties_ & PROPERTY_CONST)
	{
		if(nullptr == value_)
		{
			Error("Const variable requires initializer!");
			return false;
		}
	}

	if(nullptr == value_)
	{
		decl->append(";");
		return true;
	}

	decl->append(" = ");

	if(1 < length_)
	{
		decl->append("{");
	}

	for(uint32_t elem = 0; elem < length_; elem++)
	{
		char tmpBuff[42];
		switch(type_)
		{
		case Type::uint8_: // no break intended
		case Type::int8_:
			Error("Type not implemented!\n");
			return false;

		case Type::float_:
		{
			float* valuePt = (float*) value_;
			SNPRINTF(tmpBuff, sizeof(tmpBuff), "%.*e", DECIMAL_DIG, (double) valuePt[elem]);
		}
		break;

		case Type::int32_:
		{
			int32_t* valuePt = (int32_t*) value_;
			SNPRINTF(tmpBuff, sizeof(tmpBuff), "%i", valuePt[elem]);
		}
		break;

		default:
			Error("Unknown Type\n");
			return false;
		}

		decl->append(tmpBuff);

		if(elem != length_ -1)
		{
			decl->append(", ");
		}
	}

	if(1 < length_)
	{
		decl->append("}");
	}

	decl->append(";");

	return true;
}

const std::string* Variable::GetIdentifier() const
{
	if(0 == identifier_.length())
	{
		Error("Identifier not set!\n");
		return nullptr;
	}

	return &identifier_;
}

uint32_t Variable:: GetNewRunningNumber()
{
	runningNumber_++;
	return runningNumber_;
}

bool Variable::GetElement(std::string* elem, const char * elemIndex) const
{
	if(1 >= length_)
	{
		Error("Variable %s not an Array!\n", identifier_.c_str());
		return false;
	}

	if(0 == identifier_.length())
	{
		Error("Identifier not set!\n");
		return false;
	}

	elem->append(identifier_);

	char tmpBuff[40];
	SNPRINTF(tmpBuff, sizeof(tmpBuff), "[%s]", elemIndex);
	elem->append(tmpBuff);

	return true;
}

size_t Variable::Length() const
{
	return length_;
}


